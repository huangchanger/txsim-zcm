  sim_msg::Location start_location;
  // get start location in reset or in first step. both works.
  start_location.ParseFromString(helper.ego_start_location());
  std::cout << "Reset scenario with parameters:\n"
    << "hadmap path: " << helper.map_file_path() << "\n"
    << "the local origin coordinate of the map: (" << o.x << ", " << o.y << ", " << o.z << ")" << "\n"
    << "ego car's destination (" << d.x << ", " << d.y << ")" << std::endl;
  // we can also get the speed limit(max) info of the ego car in current scenario.
  double speed_limit = helper.ego_speed_limit();


  ofstream outfile;
  outfile.open("/home/yxj/Projects/txsim-zcm/path.txt",ios::out);
  double wgsLat1,wgsLon1,wgsLat2,wgsLon2,heading;
  UTMCoor utmXY1,utmXY2;
  outfile << "Id Lon Lat utmX utmY heading curvature mode SpeedMode EventMode OppositeSideMode LangeNum LaneSeq LaneWidth"<<endl;
  for(int i=0; i<path.size()-1; ++i){
    wgsLat1 = path[i].y;
    wgsLon1 = path[i].x;
    wgsLat2 = path[i+1].y;
    wgsLon2 = path[i+1].x;
    LatLonToUTMXY(wgsLat1,wgsLon1,utmXY1,30);
    LatLonToUTMXY(wgsLat2,wgsLon2,utmXY2,30);
    if(utmXY2.x - utmXY1.x != 0)
      heading = atan2(utmXY2.y - utmXY1.y, utmXY2.x - utmXY1.x);
    else{
      if(utmXY2.y - utmXY1.y > 0) heading = pi/2;
      if(utmXY2.y - utmXY1.y < 0) heading = -pi/2;
      if(utmXY2.y - utmXY1.y == 0) heading = 0;
    }

    outfile<<i<<" ";
    outfile.precision(14);
    outfile<<wgsLon1<<" "<<wgsLat1<<" "<<utmXY1.x<<" "<<utmXY2.y<<" "<<heading<<" "<<"0.00000000000000 0 0 0 0 0 0 0.00000000000000"<<endl;
  }
  wgsLat1 = path.back().y;
  wgsLon1 = path.back().x;
  LatLonToUTMXY(wgsLat1,wgsLon1,utmXY1,30);
  outfile<<path.size()-1<<" ";
  outfile.precision(14);
  outfile<<wgsLon1<<" "<<wgsLat1<<" "<<utmXY1.x<<" "<<utmXY2.y<<" "<<heading<<" "<<"0.00000000000000 0 0 0 0 0 0 0.00000000000000"<<endl;
  
  outfile.close();



  


