// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control.proto

#ifndef PROTOBUF_control_2eproto__INCLUDED
#define PROTOBUF_control_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "header.pb.h"
// @@protoc_insertion_point(includes)
namespace sim_msg {
class Control;
class ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class ControlSAIC;
class ControlSAICDefaultTypeInternal;
extern ControlSAICDefaultTypeInternal _ControlSAIC_default_instance_;
class Control_AccControl;
class Control_AccControlDefaultTypeInternal;
extern Control_AccControlDefaultTypeInternal _Control_AccControl_default_instance_;
class Control_AccSteerControl;
class Control_AccSteerControlDefaultTypeInternal;
extern Control_AccSteerControlDefaultTypeInternal _Control_AccSteerControl_default_instance_;
class Control_BodyCommand;
class Control_BodyCommandDefaultTypeInternal;
extern Control_BodyCommandDefaultTypeInternal _Control_BodyCommand_default_instance_;
class Control_ChassisCommand;
class Control_ChassisCommandDefaultTypeInternal;
extern Control_ChassisCommandDefaultTypeInternal _Control_ChassisCommand_default_instance_;
class Control_PedalControl;
class Control_PedalControlDefaultTypeInternal;
extern Control_PedalControlDefaultTypeInternal _Control_PedalControl_default_instance_;
class Control_PowerTrainCommand;
class Control_PowerTrainCommandDefaultTypeInternal;
extern Control_PowerTrainCommandDefaultTypeInternal _Control_PowerTrainCommand_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
}  // namespace sim_msg

namespace sim_msg {

namespace protobuf_control_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_control_2eproto

enum Control_CONTROL_MODE {
  Control_CONTROL_MODE_CM_MANUAL = 0,
  Control_CONTROL_MODE_CM_AUTO_DRIVE = 1,
  Control_CONTROL_MODE_CM_ONLY_STEER = 2,
  Control_CONTROL_MODE_CM_ONLY_SPEED = 3,
  Control_CONTROL_MODE_Control_CONTROL_MODE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Control_CONTROL_MODE_Control_CONTROL_MODE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Control_CONTROL_MODE_IsValid(int value);
const Control_CONTROL_MODE Control_CONTROL_MODE_CONTROL_MODE_MIN = Control_CONTROL_MODE_CM_MANUAL;
const Control_CONTROL_MODE Control_CONTROL_MODE_CONTROL_MODE_MAX = Control_CONTROL_MODE_CM_ONLY_SPEED;
const int Control_CONTROL_MODE_CONTROL_MODE_ARRAYSIZE = Control_CONTROL_MODE_CONTROL_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Control_CONTROL_MODE_descriptor();
inline const ::std::string& Control_CONTROL_MODE_Name(Control_CONTROL_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Control_CONTROL_MODE_descriptor(), value);
}
inline bool Control_CONTROL_MODE_Parse(
    const ::std::string& name, Control_CONTROL_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Control_CONTROL_MODE>(
    Control_CONTROL_MODE_descriptor(), name, value);
}
enum Control_GEAR_MODE {
  Control_GEAR_MODE_NO_CONTROL = 0,
  Control_GEAR_MODE_PARK = 1,
  Control_GEAR_MODE_REVERSE = 2,
  Control_GEAR_MODE_NEUTRAL = 3,
  Control_GEAR_MODE_DRIVE = 4,
  Control_GEAR_MODE_Control_GEAR_MODE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Control_GEAR_MODE_Control_GEAR_MODE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Control_GEAR_MODE_IsValid(int value);
const Control_GEAR_MODE Control_GEAR_MODE_GEAR_MODE_MIN = Control_GEAR_MODE_NO_CONTROL;
const Control_GEAR_MODE Control_GEAR_MODE_GEAR_MODE_MAX = Control_GEAR_MODE_DRIVE;
const int Control_GEAR_MODE_GEAR_MODE_ARRAYSIZE = Control_GEAR_MODE_GEAR_MODE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Control_GEAR_MODE_descriptor();
inline const ::std::string& Control_GEAR_MODE_Name(Control_GEAR_MODE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Control_GEAR_MODE_descriptor(), value);
}
inline bool Control_GEAR_MODE_Parse(
    const ::std::string& name, Control_GEAR_MODE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Control_GEAR_MODE>(
    Control_GEAR_MODE_descriptor(), name, value);
}
enum Control_CONTROL_TYPE {
  Control_CONTROL_TYPE_PEDAL_CONTROL = 0,
  Control_CONTROL_TYPE_ACC_CONTROL = 1,
  Control_CONTROL_TYPE_ACC_STEER_CONTROL = 2,
  Control_CONTROL_TYPE_Control_CONTROL_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Control_CONTROL_TYPE_Control_CONTROL_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Control_CONTROL_TYPE_IsValid(int value);
const Control_CONTROL_TYPE Control_CONTROL_TYPE_CONTROL_TYPE_MIN = Control_CONTROL_TYPE_PEDAL_CONTROL;
const Control_CONTROL_TYPE Control_CONTROL_TYPE_CONTROL_TYPE_MAX = Control_CONTROL_TYPE_ACC_STEER_CONTROL;
const int Control_CONTROL_TYPE_CONTROL_TYPE_ARRAYSIZE = Control_CONTROL_TYPE_CONTROL_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* Control_CONTROL_TYPE_descriptor();
inline const ::std::string& Control_CONTROL_TYPE_Name(Control_CONTROL_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    Control_CONTROL_TYPE_descriptor(), value);
}
inline bool Control_CONTROL_TYPE_Parse(
    const ::std::string& name, Control_CONTROL_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Control_CONTROL_TYPE>(
    Control_CONTROL_TYPE_descriptor(), name, value);
}
enum Control_TurnLight {
  Control_TurnLight_TURN_LIGHT_OFF = 0,
  Control_TurnLight_TURN_LEFT = 1,
  Control_TurnLight_TURN_RIGHT = 2,
  Control_TurnLight_Control_TurnLight_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Control_TurnLight_Control_TurnLight_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Control_TurnLight_IsValid(int value);
const Control_TurnLight Control_TurnLight_TurnLight_MIN = Control_TurnLight_TURN_LIGHT_OFF;
const Control_TurnLight Control_TurnLight_TurnLight_MAX = Control_TurnLight_TURN_RIGHT;
const int Control_TurnLight_TurnLight_ARRAYSIZE = Control_TurnLight_TurnLight_MAX + 1;

const ::google::protobuf::EnumDescriptor* Control_TurnLight_descriptor();
inline const ::std::string& Control_TurnLight_Name(Control_TurnLight value) {
  return ::google::protobuf::internal::NameOfEnum(
    Control_TurnLight_descriptor(), value);
}
inline bool Control_TurnLight_Parse(
    const ::std::string& name, Control_TurnLight* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Control_TurnLight>(
    Control_TurnLight_descriptor(), name, value);
}
enum Control_FogLamp {
  Control_FogLamp_FOG_LAMP_OFF = 0,
  Control_FogLamp_FRONT_FOG_LAMP = 1,
  Control_FogLamp_REAR_FOG_LAMP = 2,
  Control_FogLamp_ALL_FOG_LAMP = 3,
  Control_FogLamp_Control_FogLamp_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Control_FogLamp_Control_FogLamp_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Control_FogLamp_IsValid(int value);
const Control_FogLamp Control_FogLamp_FogLamp_MIN = Control_FogLamp_FOG_LAMP_OFF;
const Control_FogLamp Control_FogLamp_FogLamp_MAX = Control_FogLamp_ALL_FOG_LAMP;
const int Control_FogLamp_FogLamp_ARRAYSIZE = Control_FogLamp_FogLamp_MAX + 1;

const ::google::protobuf::EnumDescriptor* Control_FogLamp_descriptor();
inline const ::std::string& Control_FogLamp_Name(Control_FogLamp value) {
  return ::google::protobuf::internal::NameOfEnum(
    Control_FogLamp_descriptor(), value);
}
inline bool Control_FogLamp_Parse(
    const ::std::string& name, Control_FogLamp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Control_FogLamp>(
    Control_FogLamp_descriptor(), name, value);
}
// ===================================================================

class Control_PedalControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.PedalControl) */ {
 public:
  Control_PedalControl();
  virtual ~Control_PedalControl();

  Control_PedalControl(const Control_PedalControl& from);

  inline Control_PedalControl& operator=(const Control_PedalControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Control_PedalControl& default_instance();

  static inline const Control_PedalControl* internal_default_instance() {
    return reinterpret_cast<const Control_PedalControl*>(
               &_Control_PedalControl_default_instance_);
  }

  void Swap(Control_PedalControl* other);

  // implements Message ----------------------------------------------

  inline Control_PedalControl* New() const PROTOBUF_FINAL { return New(NULL); }

  Control_PedalControl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Control_PedalControl& from);
  void MergeFrom(const Control_PedalControl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Control_PedalControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double steer = 1;
  void clear_steer();
  static const int kSteerFieldNumber = 1;
  double steer() const;
  void set_steer(double value);

  // double throttle = 2;
  void clear_throttle();
  static const int kThrottleFieldNumber = 2;
  double throttle() const;
  void set_throttle(double value);

  // double brake = 3;
  void clear_brake();
  static const int kBrakeFieldNumber = 3;
  double brake() const;
  void set_brake(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.Control.PedalControl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double steer_;
  double throttle_;
  double brake_;
  mutable int _cached_size_;
  friend struct  protobuf_control_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Control_AccControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.AccControl) */ {
 public:
  Control_AccControl();
  virtual ~Control_AccControl();

  Control_AccControl(const Control_AccControl& from);

  inline Control_AccControl& operator=(const Control_AccControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Control_AccControl& default_instance();

  static inline const Control_AccControl* internal_default_instance() {
    return reinterpret_cast<const Control_AccControl*>(
               &_Control_AccControl_default_instance_);
  }

  void Swap(Control_AccControl* other);

  // implements Message ----------------------------------------------

  inline Control_AccControl* New() const PROTOBUF_FINAL { return New(NULL); }

  Control_AccControl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Control_AccControl& from);
  void MergeFrom(const Control_AccControl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Control_AccControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double acc = 1;
  void clear_acc();
  static const int kAccFieldNumber = 1;
  double acc() const;
  void set_acc(double value);

  // double front_wheel_angle = 2;
  void clear_front_wheel_angle();
  static const int kFrontWheelAngleFieldNumber = 2;
  double front_wheel_angle() const;
  void set_front_wheel_angle(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.Control.AccControl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double acc_;
  double front_wheel_angle_;
  mutable int _cached_size_;
  friend struct  protobuf_control_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Control_AccSteerControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.AccSteerControl) */ {
 public:
  Control_AccSteerControl();
  virtual ~Control_AccSteerControl();

  Control_AccSteerControl(const Control_AccSteerControl& from);

  inline Control_AccSteerControl& operator=(const Control_AccSteerControl& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Control_AccSteerControl& default_instance();

  static inline const Control_AccSteerControl* internal_default_instance() {
    return reinterpret_cast<const Control_AccSteerControl*>(
               &_Control_AccSteerControl_default_instance_);
  }

  void Swap(Control_AccSteerControl* other);

  // implements Message ----------------------------------------------

  inline Control_AccSteerControl* New() const PROTOBUF_FINAL { return New(NULL); }

  Control_AccSteerControl* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Control_AccSteerControl& from);
  void MergeFrom(const Control_AccSteerControl& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Control_AccSteerControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double acc = 1;
  void clear_acc();
  static const int kAccFieldNumber = 1;
  double acc() const;
  void set_acc(double value);

  // double steer = 2;
  void clear_steer();
  static const int kSteerFieldNumber = 2;
  double steer() const;
  void set_steer(double value);

  // @@protoc_insertion_point(class_scope:sim_msg.Control.AccSteerControl)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double acc_;
  double steer_;
  mutable int _cached_size_;
  friend struct  protobuf_control_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Control_BodyCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.BodyCommand) */ {
 public:
  Control_BodyCommand();
  virtual ~Control_BodyCommand();

  Control_BodyCommand(const Control_BodyCommand& from);

  inline Control_BodyCommand& operator=(const Control_BodyCommand& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Control_BodyCommand& default_instance();

  static inline const Control_BodyCommand* internal_default_instance() {
    return reinterpret_cast<const Control_BodyCommand*>(
               &_Control_BodyCommand_default_instance_);
  }

  void Swap(Control_BodyCommand* other);

  // implements Message ----------------------------------------------

  inline Control_BodyCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  Control_BodyCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Control_BodyCommand& from);
  void MergeFrom(const Control_BodyCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Control_BodyCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sim_msg.Control.TurnLight turn_light = 2;
  void clear_turn_light();
  static const int kTurnLightFieldNumber = 2;
  ::sim_msg::Control_TurnLight turn_light() const;
  void set_turn_light(::sim_msg::Control_TurnLight value);

  // bool horn = 1;
  void clear_horn();
  static const int kHornFieldNumber = 1;
  bool horn() const;
  void set_horn(bool value);

  // bool position_lamp = 3;
  void clear_position_lamp();
  static const int kPositionLampFieldNumber = 3;
  bool position_lamp() const;
  void set_position_lamp(bool value);

  // bool low_beam = 4;
  void clear_low_beam();
  static const int kLowBeamFieldNumber = 4;
  bool low_beam() const;
  void set_low_beam(bool value);

  // bool high_beam = 5;
  void clear_high_beam();
  static const int kHighBeamFieldNumber = 5;
  bool high_beam() const;
  void set_high_beam(bool value);

  // bool warn_light = 6;
  void clear_warn_light();
  static const int kWarnLightFieldNumber = 6;
  bool warn_light() const;
  void set_warn_light(bool value);

  // .sim_msg.Control.FogLamp fog_lamp = 7;
  void clear_fog_lamp();
  static const int kFogLampFieldNumber = 7;
  ::sim_msg::Control_FogLamp fog_lamp() const;
  void set_fog_lamp(::sim_msg::Control_FogLamp value);

  // @@protoc_insertion_point(class_scope:sim_msg.Control.BodyCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int turn_light_;
  bool horn_;
  bool position_lamp_;
  bool low_beam_;
  bool high_beam_;
  bool warn_light_;
  int fog_lamp_;
  mutable int _cached_size_;
  friend struct  protobuf_control_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Control_ChassisCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.ChassisCommand) */ {
 public:
  Control_ChassisCommand();
  virtual ~Control_ChassisCommand();

  Control_ChassisCommand(const Control_ChassisCommand& from);

  inline Control_ChassisCommand& operator=(const Control_ChassisCommand& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Control_ChassisCommand& default_instance();

  static inline const Control_ChassisCommand* internal_default_instance() {
    return reinterpret_cast<const Control_ChassisCommand*>(
               &_Control_ChassisCommand_default_instance_);
  }

  void Swap(Control_ChassisCommand* other);

  // implements Message ----------------------------------------------

  inline Control_ChassisCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  Control_ChassisCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Control_ChassisCommand& from);
  void MergeFrom(const Control_ChassisCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Control_ChassisCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool epb = 1;
  void clear_epb();
  static const int kEpbFieldNumber = 1;
  bool epb() const;
  void set_epb(bool value);

  // @@protoc_insertion_point(class_scope:sim_msg.Control.ChassisCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool epb_;
  mutable int _cached_size_;
  friend struct  protobuf_control_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Control_PowerTrainCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.PowerTrainCommand) */ {
 public:
  Control_PowerTrainCommand();
  virtual ~Control_PowerTrainCommand();

  Control_PowerTrainCommand(const Control_PowerTrainCommand& from);

  inline Control_PowerTrainCommand& operator=(const Control_PowerTrainCommand& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Control_PowerTrainCommand& default_instance();

  static inline const Control_PowerTrainCommand* internal_default_instance() {
    return reinterpret_cast<const Control_PowerTrainCommand*>(
               &_Control_PowerTrainCommand_default_instance_);
  }

  void Swap(Control_PowerTrainCommand* other);

  // implements Message ----------------------------------------------

  inline Control_PowerTrainCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  Control_PowerTrainCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Control_PowerTrainCommand& from);
  void MergeFrom(const Control_PowerTrainCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Control_PowerTrainCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool switch_off_engine = 1;
  void clear_switch_off_engine();
  static const int kSwitchOffEngineFieldNumber = 1;
  bool switch_off_engine() const;
  void set_switch_off_engine(bool value);

  // @@protoc_insertion_point(class_scope:sim_msg.Control.PowerTrainCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool switch_off_engine_;
  mutable int _cached_size_;
  friend struct  protobuf_control_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Control : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control) */ {
 public:
  Control();
  virtual ~Control();

  Control(const Control& from);

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Control& default_instance();

  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }

  void Swap(Control* other);

  // implements Message ----------------------------------------------

  inline Control* New() const PROTOBUF_FINAL { return New(NULL); }

  Control* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Control& from);
  void MergeFrom(const Control& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Control* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Control_PedalControl PedalControl;
  typedef Control_AccControl AccControl;
  typedef Control_AccSteerControl AccSteerControl;
  typedef Control_BodyCommand BodyCommand;
  typedef Control_ChassisCommand ChassisCommand;
  typedef Control_PowerTrainCommand PowerTrainCommand;

  typedef Control_CONTROL_MODE CONTROL_MODE;
  static const CONTROL_MODE CM_MANUAL =
    Control_CONTROL_MODE_CM_MANUAL;
  static const CONTROL_MODE CM_AUTO_DRIVE =
    Control_CONTROL_MODE_CM_AUTO_DRIVE;
  static const CONTROL_MODE CM_ONLY_STEER =
    Control_CONTROL_MODE_CM_ONLY_STEER;
  static const CONTROL_MODE CM_ONLY_SPEED =
    Control_CONTROL_MODE_CM_ONLY_SPEED;
  static inline bool CONTROL_MODE_IsValid(int value) {
    return Control_CONTROL_MODE_IsValid(value);
  }
  static const CONTROL_MODE CONTROL_MODE_MIN =
    Control_CONTROL_MODE_CONTROL_MODE_MIN;
  static const CONTROL_MODE CONTROL_MODE_MAX =
    Control_CONTROL_MODE_CONTROL_MODE_MAX;
  static const int CONTROL_MODE_ARRAYSIZE =
    Control_CONTROL_MODE_CONTROL_MODE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CONTROL_MODE_descriptor() {
    return Control_CONTROL_MODE_descriptor();
  }
  static inline const ::std::string& CONTROL_MODE_Name(CONTROL_MODE value) {
    return Control_CONTROL_MODE_Name(value);
  }
  static inline bool CONTROL_MODE_Parse(const ::std::string& name,
      CONTROL_MODE* value) {
    return Control_CONTROL_MODE_Parse(name, value);
  }

  typedef Control_GEAR_MODE GEAR_MODE;
  static const GEAR_MODE NO_CONTROL =
    Control_GEAR_MODE_NO_CONTROL;
  static const GEAR_MODE PARK =
    Control_GEAR_MODE_PARK;
  static const GEAR_MODE REVERSE =
    Control_GEAR_MODE_REVERSE;
  static const GEAR_MODE NEUTRAL =
    Control_GEAR_MODE_NEUTRAL;
  static const GEAR_MODE DRIVE =
    Control_GEAR_MODE_DRIVE;
  static inline bool GEAR_MODE_IsValid(int value) {
    return Control_GEAR_MODE_IsValid(value);
  }
  static const GEAR_MODE GEAR_MODE_MIN =
    Control_GEAR_MODE_GEAR_MODE_MIN;
  static const GEAR_MODE GEAR_MODE_MAX =
    Control_GEAR_MODE_GEAR_MODE_MAX;
  static const int GEAR_MODE_ARRAYSIZE =
    Control_GEAR_MODE_GEAR_MODE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  GEAR_MODE_descriptor() {
    return Control_GEAR_MODE_descriptor();
  }
  static inline const ::std::string& GEAR_MODE_Name(GEAR_MODE value) {
    return Control_GEAR_MODE_Name(value);
  }
  static inline bool GEAR_MODE_Parse(const ::std::string& name,
      GEAR_MODE* value) {
    return Control_GEAR_MODE_Parse(name, value);
  }

  typedef Control_CONTROL_TYPE CONTROL_TYPE;
  static const CONTROL_TYPE PEDAL_CONTROL =
    Control_CONTROL_TYPE_PEDAL_CONTROL;
  static const CONTROL_TYPE ACC_CONTROL =
    Control_CONTROL_TYPE_ACC_CONTROL;
  static const CONTROL_TYPE ACC_STEER_CONTROL =
    Control_CONTROL_TYPE_ACC_STEER_CONTROL;
  static inline bool CONTROL_TYPE_IsValid(int value) {
    return Control_CONTROL_TYPE_IsValid(value);
  }
  static const CONTROL_TYPE CONTROL_TYPE_MIN =
    Control_CONTROL_TYPE_CONTROL_TYPE_MIN;
  static const CONTROL_TYPE CONTROL_TYPE_MAX =
    Control_CONTROL_TYPE_CONTROL_TYPE_MAX;
  static const int CONTROL_TYPE_ARRAYSIZE =
    Control_CONTROL_TYPE_CONTROL_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CONTROL_TYPE_descriptor() {
    return Control_CONTROL_TYPE_descriptor();
  }
  static inline const ::std::string& CONTROL_TYPE_Name(CONTROL_TYPE value) {
    return Control_CONTROL_TYPE_Name(value);
  }
  static inline bool CONTROL_TYPE_Parse(const ::std::string& name,
      CONTROL_TYPE* value) {
    return Control_CONTROL_TYPE_Parse(name, value);
  }

  typedef Control_TurnLight TurnLight;
  static const TurnLight TURN_LIGHT_OFF =
    Control_TurnLight_TURN_LIGHT_OFF;
  static const TurnLight TURN_LEFT =
    Control_TurnLight_TURN_LEFT;
  static const TurnLight TURN_RIGHT =
    Control_TurnLight_TURN_RIGHT;
  static inline bool TurnLight_IsValid(int value) {
    return Control_TurnLight_IsValid(value);
  }
  static const TurnLight TurnLight_MIN =
    Control_TurnLight_TurnLight_MIN;
  static const TurnLight TurnLight_MAX =
    Control_TurnLight_TurnLight_MAX;
  static const int TurnLight_ARRAYSIZE =
    Control_TurnLight_TurnLight_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TurnLight_descriptor() {
    return Control_TurnLight_descriptor();
  }
  static inline const ::std::string& TurnLight_Name(TurnLight value) {
    return Control_TurnLight_Name(value);
  }
  static inline bool TurnLight_Parse(const ::std::string& name,
      TurnLight* value) {
    return Control_TurnLight_Parse(name, value);
  }

  typedef Control_FogLamp FogLamp;
  static const FogLamp FOG_LAMP_OFF =
    Control_FogLamp_FOG_LAMP_OFF;
  static const FogLamp FRONT_FOG_LAMP =
    Control_FogLamp_FRONT_FOG_LAMP;
  static const FogLamp REAR_FOG_LAMP =
    Control_FogLamp_REAR_FOG_LAMP;
  static const FogLamp ALL_FOG_LAMP =
    Control_FogLamp_ALL_FOG_LAMP;
  static inline bool FogLamp_IsValid(int value) {
    return Control_FogLamp_IsValid(value);
  }
  static const FogLamp FogLamp_MIN =
    Control_FogLamp_FogLamp_MIN;
  static const FogLamp FogLamp_MAX =
    Control_FogLamp_FogLamp_MAX;
  static const int FogLamp_ARRAYSIZE =
    Control_FogLamp_FogLamp_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FogLamp_descriptor() {
    return Control_FogLamp_descriptor();
  }
  static inline const ::std::string& FogLamp_Name(FogLamp value) {
    return Control_FogLamp_Name(value);
  }
  static inline bool FogLamp_Parse(const ::std::string& name,
      FogLamp* value) {
    return Control_FogLamp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .sim_msg.Header header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::sim_msg::Header& header() const;
  ::sim_msg::Header* mutable_header();
  ::sim_msg::Header* release_header();
  void set_allocated_header(::sim_msg::Header* header);

  // .sim_msg.Control.PedalControl pedal_cmd = 5;
  bool has_pedal_cmd() const;
  void clear_pedal_cmd();
  static const int kPedalCmdFieldNumber = 5;
  const ::sim_msg::Control_PedalControl& pedal_cmd() const;
  ::sim_msg::Control_PedalControl* mutable_pedal_cmd();
  ::sim_msg::Control_PedalControl* release_pedal_cmd();
  void set_allocated_pedal_cmd(::sim_msg::Control_PedalControl* pedal_cmd);

  // .sim_msg.Control.AccControl acc_cmd = 6;
  bool has_acc_cmd() const;
  void clear_acc_cmd();
  static const int kAccCmdFieldNumber = 6;
  const ::sim_msg::Control_AccControl& acc_cmd() const;
  ::sim_msg::Control_AccControl* mutable_acc_cmd();
  ::sim_msg::Control_AccControl* release_acc_cmd();
  void set_allocated_acc_cmd(::sim_msg::Control_AccControl* acc_cmd);

  // .sim_msg.Control.BodyCommand body_cmd = 7;
  bool has_body_cmd() const;
  void clear_body_cmd();
  static const int kBodyCmdFieldNumber = 7;
  const ::sim_msg::Control_BodyCommand& body_cmd() const;
  ::sim_msg::Control_BodyCommand* mutable_body_cmd();
  ::sim_msg::Control_BodyCommand* release_body_cmd();
  void set_allocated_body_cmd(::sim_msg::Control_BodyCommand* body_cmd);

  // .sim_msg.Control.ChassisCommand chassis_cmd = 8;
  bool has_chassis_cmd() const;
  void clear_chassis_cmd();
  static const int kChassisCmdFieldNumber = 8;
  const ::sim_msg::Control_ChassisCommand& chassis_cmd() const;
  ::sim_msg::Control_ChassisCommand* mutable_chassis_cmd();
  ::sim_msg::Control_ChassisCommand* release_chassis_cmd();
  void set_allocated_chassis_cmd(::sim_msg::Control_ChassisCommand* chassis_cmd);

  // .sim_msg.Control.PowerTrainCommand powertrain_cmd = 9;
  bool has_powertrain_cmd() const;
  void clear_powertrain_cmd();
  static const int kPowertrainCmdFieldNumber = 9;
  const ::sim_msg::Control_PowerTrainCommand& powertrain_cmd() const;
  ::sim_msg::Control_PowerTrainCommand* mutable_powertrain_cmd();
  ::sim_msg::Control_PowerTrainCommand* release_powertrain_cmd();
  void set_allocated_powertrain_cmd(::sim_msg::Control_PowerTrainCommand* powertrain_cmd);

  // .sim_msg.Control.AccSteerControl acc_steer_cmd = 10;
  bool has_acc_steer_cmd() const;
  void clear_acc_steer_cmd();
  static const int kAccSteerCmdFieldNumber = 10;
  const ::sim_msg::Control_AccSteerControl& acc_steer_cmd() const;
  ::sim_msg::Control_AccSteerControl* mutable_acc_steer_cmd();
  ::sim_msg::Control_AccSteerControl* release_acc_steer_cmd();
  void set_allocated_acc_steer_cmd(::sim_msg::Control_AccSteerControl* acc_steer_cmd);

  // .sim_msg.Control.CONTROL_MODE control_mode = 2;
  void clear_control_mode();
  static const int kControlModeFieldNumber = 2;
  ::sim_msg::Control_CONTROL_MODE control_mode() const;
  void set_control_mode(::sim_msg::Control_CONTROL_MODE value);

  // .sim_msg.Control.CONTROL_TYPE contrl_type = 3;
  void clear_contrl_type();
  static const int kContrlTypeFieldNumber = 3;
  ::sim_msg::Control_CONTROL_TYPE contrl_type() const;
  void set_contrl_type(::sim_msg::Control_CONTROL_TYPE value);

  // .sim_msg.Control.GEAR_MODE gear_cmd = 4;
  void clear_gear_cmd();
  static const int kGearCmdFieldNumber = 4;
  ::sim_msg::Control_GEAR_MODE gear_cmd() const;
  void set_gear_cmd(::sim_msg::Control_GEAR_MODE value);

  // @@protoc_insertion_point(class_scope:sim_msg.Control)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sim_msg::Header* header_;
  ::sim_msg::Control_PedalControl* pedal_cmd_;
  ::sim_msg::Control_AccControl* acc_cmd_;
  ::sim_msg::Control_BodyCommand* body_cmd_;
  ::sim_msg::Control_ChassisCommand* chassis_cmd_;
  ::sim_msg::Control_PowerTrainCommand* powertrain_cmd_;
  ::sim_msg::Control_AccSteerControl* acc_steer_cmd_;
  int control_mode_;
  int contrl_type_;
  int gear_cmd_;
  mutable int _cached_size_;
  friend struct  protobuf_control_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ControlSAIC : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sim_msg.ControlSAIC) */ {
 public:
  ControlSAIC();
  virtual ~ControlSAIC();

  ControlSAIC(const ControlSAIC& from);

  inline ControlSAIC& operator=(const ControlSAIC& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlSAIC& default_instance();

  static inline const ControlSAIC* internal_default_instance() {
    return reinterpret_cast<const ControlSAIC*>(
               &_ControlSAIC_default_instance_);
  }

  void Swap(ControlSAIC* other);

  // implements Message ----------------------------------------------

  inline ControlSAIC* New() const PROTOBUF_FINAL { return New(NULL); }

  ControlSAIC* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ControlSAIC& from);
  void MergeFrom(const ControlSAIC& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ControlSAIC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double torqueReq = 1;
  void clear_torquereq();
  static const int kTorqueReqFieldNumber = 1;
  double torquereq() const;
  void set_torquereq(double value);

  // double steerReq = 2;
  void clear_steerreq();
  static const int kSteerReqFieldNumber = 2;
  double steerreq() const;
  void set_steerreq(double value);

  // double brakePressureReq = 4;
  void clear_brakepressurereq();
  static const int kBrakePressureReqFieldNumber = 4;
  double brakepressurereq() const;
  void set_brakepressurereq(double value);

  // double accReq = 5;
  void clear_accreq();
  static const int kAccReqFieldNumber = 5;
  double accreq() const;
  void set_accreq(double value);

  // int32 driveModeReq = 3;
  void clear_drivemodereq();
  static const int kDriveModeReqFieldNumber = 3;
  ::google::protobuf::int32 drivemodereq() const;
  void set_drivemodereq(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sim_msg.ControlSAIC)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double torquereq_;
  double steerreq_;
  double brakepressurereq_;
  double accreq_;
  ::google::protobuf::int32 drivemodereq_;
  mutable int _cached_size_;
  friend struct  protobuf_control_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Control_PedalControl

// double steer = 1;
inline void Control_PedalControl::clear_steer() {
  steer_ = 0;
}
inline double Control_PedalControl::steer() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.PedalControl.steer)
  return steer_;
}
inline void Control_PedalControl::set_steer(double value) {
  
  steer_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.PedalControl.steer)
}

// double throttle = 2;
inline void Control_PedalControl::clear_throttle() {
  throttle_ = 0;
}
inline double Control_PedalControl::throttle() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.PedalControl.throttle)
  return throttle_;
}
inline void Control_PedalControl::set_throttle(double value) {
  
  throttle_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.PedalControl.throttle)
}

// double brake = 3;
inline void Control_PedalControl::clear_brake() {
  brake_ = 0;
}
inline double Control_PedalControl::brake() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.PedalControl.brake)
  return brake_;
}
inline void Control_PedalControl::set_brake(double value) {
  
  brake_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.PedalControl.brake)
}

// -------------------------------------------------------------------

// Control_AccControl

// double acc = 1;
inline void Control_AccControl::clear_acc() {
  acc_ = 0;
}
inline double Control_AccControl::acc() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.AccControl.acc)
  return acc_;
}
inline void Control_AccControl::set_acc(double value) {
  
  acc_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.AccControl.acc)
}

// double front_wheel_angle = 2;
inline void Control_AccControl::clear_front_wheel_angle() {
  front_wheel_angle_ = 0;
}
inline double Control_AccControl::front_wheel_angle() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.AccControl.front_wheel_angle)
  return front_wheel_angle_;
}
inline void Control_AccControl::set_front_wheel_angle(double value) {
  
  front_wheel_angle_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.AccControl.front_wheel_angle)
}

// -------------------------------------------------------------------

// Control_AccSteerControl

// double acc = 1;
inline void Control_AccSteerControl::clear_acc() {
  acc_ = 0;
}
inline double Control_AccSteerControl::acc() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.AccSteerControl.acc)
  return acc_;
}
inline void Control_AccSteerControl::set_acc(double value) {
  
  acc_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.AccSteerControl.acc)
}

// double steer = 2;
inline void Control_AccSteerControl::clear_steer() {
  steer_ = 0;
}
inline double Control_AccSteerControl::steer() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.AccSteerControl.steer)
  return steer_;
}
inline void Control_AccSteerControl::set_steer(double value) {
  
  steer_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.AccSteerControl.steer)
}

// -------------------------------------------------------------------

// Control_BodyCommand

// bool horn = 1;
inline void Control_BodyCommand::clear_horn() {
  horn_ = false;
}
inline bool Control_BodyCommand::horn() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.horn)
  return horn_;
}
inline void Control_BodyCommand::set_horn(bool value) {
  
  horn_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.horn)
}

// .sim_msg.Control.TurnLight turn_light = 2;
inline void Control_BodyCommand::clear_turn_light() {
  turn_light_ = 0;
}
inline ::sim_msg::Control_TurnLight Control_BodyCommand::turn_light() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.turn_light)
  return static_cast< ::sim_msg::Control_TurnLight >(turn_light_);
}
inline void Control_BodyCommand::set_turn_light(::sim_msg::Control_TurnLight value) {
  
  turn_light_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.turn_light)
}

// bool position_lamp = 3;
inline void Control_BodyCommand::clear_position_lamp() {
  position_lamp_ = false;
}
inline bool Control_BodyCommand::position_lamp() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.position_lamp)
  return position_lamp_;
}
inline void Control_BodyCommand::set_position_lamp(bool value) {
  
  position_lamp_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.position_lamp)
}

// bool low_beam = 4;
inline void Control_BodyCommand::clear_low_beam() {
  low_beam_ = false;
}
inline bool Control_BodyCommand::low_beam() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.low_beam)
  return low_beam_;
}
inline void Control_BodyCommand::set_low_beam(bool value) {
  
  low_beam_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.low_beam)
}

// bool high_beam = 5;
inline void Control_BodyCommand::clear_high_beam() {
  high_beam_ = false;
}
inline bool Control_BodyCommand::high_beam() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.high_beam)
  return high_beam_;
}
inline void Control_BodyCommand::set_high_beam(bool value) {
  
  high_beam_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.high_beam)
}

// bool warn_light = 6;
inline void Control_BodyCommand::clear_warn_light() {
  warn_light_ = false;
}
inline bool Control_BodyCommand::warn_light() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.warn_light)
  return warn_light_;
}
inline void Control_BodyCommand::set_warn_light(bool value) {
  
  warn_light_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.warn_light)
}

// .sim_msg.Control.FogLamp fog_lamp = 7;
inline void Control_BodyCommand::clear_fog_lamp() {
  fog_lamp_ = 0;
}
inline ::sim_msg::Control_FogLamp Control_BodyCommand::fog_lamp() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.fog_lamp)
  return static_cast< ::sim_msg::Control_FogLamp >(fog_lamp_);
}
inline void Control_BodyCommand::set_fog_lamp(::sim_msg::Control_FogLamp value) {
  
  fog_lamp_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.fog_lamp)
}

// -------------------------------------------------------------------

// Control_ChassisCommand

// bool epb = 1;
inline void Control_ChassisCommand::clear_epb() {
  epb_ = false;
}
inline bool Control_ChassisCommand::epb() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.ChassisCommand.epb)
  return epb_;
}
inline void Control_ChassisCommand::set_epb(bool value) {
  
  epb_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.ChassisCommand.epb)
}

// -------------------------------------------------------------------

// Control_PowerTrainCommand

// bool switch_off_engine = 1;
inline void Control_PowerTrainCommand::clear_switch_off_engine() {
  switch_off_engine_ = false;
}
inline bool Control_PowerTrainCommand::switch_off_engine() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.PowerTrainCommand.switch_off_engine)
  return switch_off_engine_;
}
inline void Control_PowerTrainCommand::set_switch_off_engine(bool value) {
  
  switch_off_engine_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.PowerTrainCommand.switch_off_engine)
}

// -------------------------------------------------------------------

// Control

// .sim_msg.Header header = 1;
inline bool Control::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void Control::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::sim_msg::Header& Control::header() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.header)
  return header_ != NULL ? *header_
                         : *::sim_msg::Header::internal_default_instance();
}
inline ::sim_msg::Header* Control::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::sim_msg::Header;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.header)
  return header_;
}
inline ::sim_msg::Header* Control::release_header() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.header)
  
  ::sim_msg::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Control::set_allocated_header(::sim_msg::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.header)
}

// .sim_msg.Control.CONTROL_MODE control_mode = 2;
inline void Control::clear_control_mode() {
  control_mode_ = 0;
}
inline ::sim_msg::Control_CONTROL_MODE Control::control_mode() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.control_mode)
  return static_cast< ::sim_msg::Control_CONTROL_MODE >(control_mode_);
}
inline void Control::set_control_mode(::sim_msg::Control_CONTROL_MODE value) {
  
  control_mode_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.control_mode)
}

// .sim_msg.Control.CONTROL_TYPE contrl_type = 3;
inline void Control::clear_contrl_type() {
  contrl_type_ = 0;
}
inline ::sim_msg::Control_CONTROL_TYPE Control::contrl_type() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.contrl_type)
  return static_cast< ::sim_msg::Control_CONTROL_TYPE >(contrl_type_);
}
inline void Control::set_contrl_type(::sim_msg::Control_CONTROL_TYPE value) {
  
  contrl_type_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.contrl_type)
}

// .sim_msg.Control.GEAR_MODE gear_cmd = 4;
inline void Control::clear_gear_cmd() {
  gear_cmd_ = 0;
}
inline ::sim_msg::Control_GEAR_MODE Control::gear_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.gear_cmd)
  return static_cast< ::sim_msg::Control_GEAR_MODE >(gear_cmd_);
}
inline void Control::set_gear_cmd(::sim_msg::Control_GEAR_MODE value) {
  
  gear_cmd_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.Control.gear_cmd)
}

// .sim_msg.Control.PedalControl pedal_cmd = 5;
inline bool Control::has_pedal_cmd() const {
  return this != internal_default_instance() && pedal_cmd_ != NULL;
}
inline void Control::clear_pedal_cmd() {
  if (GetArenaNoVirtual() == NULL && pedal_cmd_ != NULL) delete pedal_cmd_;
  pedal_cmd_ = NULL;
}
inline const ::sim_msg::Control_PedalControl& Control::pedal_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.pedal_cmd)
  return pedal_cmd_ != NULL ? *pedal_cmd_
                         : *::sim_msg::Control_PedalControl::internal_default_instance();
}
inline ::sim_msg::Control_PedalControl* Control::mutable_pedal_cmd() {
  
  if (pedal_cmd_ == NULL) {
    pedal_cmd_ = new ::sim_msg::Control_PedalControl;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.pedal_cmd)
  return pedal_cmd_;
}
inline ::sim_msg::Control_PedalControl* Control::release_pedal_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.pedal_cmd)
  
  ::sim_msg::Control_PedalControl* temp = pedal_cmd_;
  pedal_cmd_ = NULL;
  return temp;
}
inline void Control::set_allocated_pedal_cmd(::sim_msg::Control_PedalControl* pedal_cmd) {
  delete pedal_cmd_;
  pedal_cmd_ = pedal_cmd;
  if (pedal_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.pedal_cmd)
}

// .sim_msg.Control.AccControl acc_cmd = 6;
inline bool Control::has_acc_cmd() const {
  return this != internal_default_instance() && acc_cmd_ != NULL;
}
inline void Control::clear_acc_cmd() {
  if (GetArenaNoVirtual() == NULL && acc_cmd_ != NULL) delete acc_cmd_;
  acc_cmd_ = NULL;
}
inline const ::sim_msg::Control_AccControl& Control::acc_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.acc_cmd)
  return acc_cmd_ != NULL ? *acc_cmd_
                         : *::sim_msg::Control_AccControl::internal_default_instance();
}
inline ::sim_msg::Control_AccControl* Control::mutable_acc_cmd() {
  
  if (acc_cmd_ == NULL) {
    acc_cmd_ = new ::sim_msg::Control_AccControl;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.acc_cmd)
  return acc_cmd_;
}
inline ::sim_msg::Control_AccControl* Control::release_acc_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.acc_cmd)
  
  ::sim_msg::Control_AccControl* temp = acc_cmd_;
  acc_cmd_ = NULL;
  return temp;
}
inline void Control::set_allocated_acc_cmd(::sim_msg::Control_AccControl* acc_cmd) {
  delete acc_cmd_;
  acc_cmd_ = acc_cmd;
  if (acc_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.acc_cmd)
}

// .sim_msg.Control.BodyCommand body_cmd = 7;
inline bool Control::has_body_cmd() const {
  return this != internal_default_instance() && body_cmd_ != NULL;
}
inline void Control::clear_body_cmd() {
  if (GetArenaNoVirtual() == NULL && body_cmd_ != NULL) delete body_cmd_;
  body_cmd_ = NULL;
}
inline const ::sim_msg::Control_BodyCommand& Control::body_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.body_cmd)
  return body_cmd_ != NULL ? *body_cmd_
                         : *::sim_msg::Control_BodyCommand::internal_default_instance();
}
inline ::sim_msg::Control_BodyCommand* Control::mutable_body_cmd() {
  
  if (body_cmd_ == NULL) {
    body_cmd_ = new ::sim_msg::Control_BodyCommand;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.body_cmd)
  return body_cmd_;
}
inline ::sim_msg::Control_BodyCommand* Control::release_body_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.body_cmd)
  
  ::sim_msg::Control_BodyCommand* temp = body_cmd_;
  body_cmd_ = NULL;
  return temp;
}
inline void Control::set_allocated_body_cmd(::sim_msg::Control_BodyCommand* body_cmd) {
  delete body_cmd_;
  body_cmd_ = body_cmd;
  if (body_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.body_cmd)
}

// .sim_msg.Control.ChassisCommand chassis_cmd = 8;
inline bool Control::has_chassis_cmd() const {
  return this != internal_default_instance() && chassis_cmd_ != NULL;
}
inline void Control::clear_chassis_cmd() {
  if (GetArenaNoVirtual() == NULL && chassis_cmd_ != NULL) delete chassis_cmd_;
  chassis_cmd_ = NULL;
}
inline const ::sim_msg::Control_ChassisCommand& Control::chassis_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.chassis_cmd)
  return chassis_cmd_ != NULL ? *chassis_cmd_
                         : *::sim_msg::Control_ChassisCommand::internal_default_instance();
}
inline ::sim_msg::Control_ChassisCommand* Control::mutable_chassis_cmd() {
  
  if (chassis_cmd_ == NULL) {
    chassis_cmd_ = new ::sim_msg::Control_ChassisCommand;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.chassis_cmd)
  return chassis_cmd_;
}
inline ::sim_msg::Control_ChassisCommand* Control::release_chassis_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.chassis_cmd)
  
  ::sim_msg::Control_ChassisCommand* temp = chassis_cmd_;
  chassis_cmd_ = NULL;
  return temp;
}
inline void Control::set_allocated_chassis_cmd(::sim_msg::Control_ChassisCommand* chassis_cmd) {
  delete chassis_cmd_;
  chassis_cmd_ = chassis_cmd;
  if (chassis_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.chassis_cmd)
}

// .sim_msg.Control.PowerTrainCommand powertrain_cmd = 9;
inline bool Control::has_powertrain_cmd() const {
  return this != internal_default_instance() && powertrain_cmd_ != NULL;
}
inline void Control::clear_powertrain_cmd() {
  if (GetArenaNoVirtual() == NULL && powertrain_cmd_ != NULL) delete powertrain_cmd_;
  powertrain_cmd_ = NULL;
}
inline const ::sim_msg::Control_PowerTrainCommand& Control::powertrain_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.powertrain_cmd)
  return powertrain_cmd_ != NULL ? *powertrain_cmd_
                         : *::sim_msg::Control_PowerTrainCommand::internal_default_instance();
}
inline ::sim_msg::Control_PowerTrainCommand* Control::mutable_powertrain_cmd() {
  
  if (powertrain_cmd_ == NULL) {
    powertrain_cmd_ = new ::sim_msg::Control_PowerTrainCommand;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.powertrain_cmd)
  return powertrain_cmd_;
}
inline ::sim_msg::Control_PowerTrainCommand* Control::release_powertrain_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.powertrain_cmd)
  
  ::sim_msg::Control_PowerTrainCommand* temp = powertrain_cmd_;
  powertrain_cmd_ = NULL;
  return temp;
}
inline void Control::set_allocated_powertrain_cmd(::sim_msg::Control_PowerTrainCommand* powertrain_cmd) {
  delete powertrain_cmd_;
  powertrain_cmd_ = powertrain_cmd;
  if (powertrain_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.powertrain_cmd)
}

// .sim_msg.Control.AccSteerControl acc_steer_cmd = 10;
inline bool Control::has_acc_steer_cmd() const {
  return this != internal_default_instance() && acc_steer_cmd_ != NULL;
}
inline void Control::clear_acc_steer_cmd() {
  if (GetArenaNoVirtual() == NULL && acc_steer_cmd_ != NULL) delete acc_steer_cmd_;
  acc_steer_cmd_ = NULL;
}
inline const ::sim_msg::Control_AccSteerControl& Control::acc_steer_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.acc_steer_cmd)
  return acc_steer_cmd_ != NULL ? *acc_steer_cmd_
                         : *::sim_msg::Control_AccSteerControl::internal_default_instance();
}
inline ::sim_msg::Control_AccSteerControl* Control::mutable_acc_steer_cmd() {
  
  if (acc_steer_cmd_ == NULL) {
    acc_steer_cmd_ = new ::sim_msg::Control_AccSteerControl;
  }
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.acc_steer_cmd)
  return acc_steer_cmd_;
}
inline ::sim_msg::Control_AccSteerControl* Control::release_acc_steer_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.acc_steer_cmd)
  
  ::sim_msg::Control_AccSteerControl* temp = acc_steer_cmd_;
  acc_steer_cmd_ = NULL;
  return temp;
}
inline void Control::set_allocated_acc_steer_cmd(::sim_msg::Control_AccSteerControl* acc_steer_cmd) {
  delete acc_steer_cmd_;
  acc_steer_cmd_ = acc_steer_cmd;
  if (acc_steer_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.acc_steer_cmd)
}

// -------------------------------------------------------------------

// ControlSAIC

// double torqueReq = 1;
inline void ControlSAIC::clear_torquereq() {
  torquereq_ = 0;
}
inline double ControlSAIC::torquereq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.torqueReq)
  return torquereq_;
}
inline void ControlSAIC::set_torquereq(double value) {
  
  torquereq_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.torqueReq)
}

// double steerReq = 2;
inline void ControlSAIC::clear_steerreq() {
  steerreq_ = 0;
}
inline double ControlSAIC::steerreq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.steerReq)
  return steerreq_;
}
inline void ControlSAIC::set_steerreq(double value) {
  
  steerreq_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.steerReq)
}

// int32 driveModeReq = 3;
inline void ControlSAIC::clear_drivemodereq() {
  drivemodereq_ = 0;
}
inline ::google::protobuf::int32 ControlSAIC::drivemodereq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.driveModeReq)
  return drivemodereq_;
}
inline void ControlSAIC::set_drivemodereq(::google::protobuf::int32 value) {
  
  drivemodereq_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.driveModeReq)
}

// double brakePressureReq = 4;
inline void ControlSAIC::clear_brakepressurereq() {
  brakepressurereq_ = 0;
}
inline double ControlSAIC::brakepressurereq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.brakePressureReq)
  return brakepressurereq_;
}
inline void ControlSAIC::set_brakepressurereq(double value) {
  
  brakepressurereq_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.brakePressureReq)
}

// double accReq = 5;
inline void ControlSAIC::clear_accreq() {
  accreq_ = 0;
}
inline double ControlSAIC::accreq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.accReq)
  return accreq_;
}
inline void ControlSAIC::set_accreq(double value) {
  
  accreq_ = value;
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.accReq)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace sim_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::sim_msg::Control_CONTROL_MODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_CONTROL_MODE>() {
  return ::sim_msg::Control_CONTROL_MODE_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Control_GEAR_MODE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_GEAR_MODE>() {
  return ::sim_msg::Control_GEAR_MODE_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Control_CONTROL_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_CONTROL_TYPE>() {
  return ::sim_msg::Control_CONTROL_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Control_TurnLight> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_TurnLight>() {
  return ::sim_msg::Control_TurnLight_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Control_FogLamp> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_FogLamp>() {
  return ::sim_msg::Control_FogLamp_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_control_2eproto__INCLUDED
