// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: control.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_control_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_control_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "header.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_control_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_control_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_control_2eproto;
namespace sim_msg {
class Control;
struct ControlDefaultTypeInternal;
extern ControlDefaultTypeInternal _Control_default_instance_;
class ControlSAIC;
struct ControlSAICDefaultTypeInternal;
extern ControlSAICDefaultTypeInternal _ControlSAIC_default_instance_;
class Control_AccControl;
struct Control_AccControlDefaultTypeInternal;
extern Control_AccControlDefaultTypeInternal _Control_AccControl_default_instance_;
class Control_AccSteerControl;
struct Control_AccSteerControlDefaultTypeInternal;
extern Control_AccSteerControlDefaultTypeInternal _Control_AccSteerControl_default_instance_;
class Control_BodyCommand;
struct Control_BodyCommandDefaultTypeInternal;
extern Control_BodyCommandDefaultTypeInternal _Control_BodyCommand_default_instance_;
class Control_ChassisCommand;
struct Control_ChassisCommandDefaultTypeInternal;
extern Control_ChassisCommandDefaultTypeInternal _Control_ChassisCommand_default_instance_;
class Control_PedalControl;
struct Control_PedalControlDefaultTypeInternal;
extern Control_PedalControlDefaultTypeInternal _Control_PedalControl_default_instance_;
class Control_PowerTrainCommand;
struct Control_PowerTrainCommandDefaultTypeInternal;
extern Control_PowerTrainCommandDefaultTypeInternal _Control_PowerTrainCommand_default_instance_;
}  // namespace sim_msg
PROTOBUF_NAMESPACE_OPEN
template<> ::sim_msg::Control* Arena::CreateMaybeMessage<::sim_msg::Control>(Arena*);
template<> ::sim_msg::ControlSAIC* Arena::CreateMaybeMessage<::sim_msg::ControlSAIC>(Arena*);
template<> ::sim_msg::Control_AccControl* Arena::CreateMaybeMessage<::sim_msg::Control_AccControl>(Arena*);
template<> ::sim_msg::Control_AccSteerControl* Arena::CreateMaybeMessage<::sim_msg::Control_AccSteerControl>(Arena*);
template<> ::sim_msg::Control_BodyCommand* Arena::CreateMaybeMessage<::sim_msg::Control_BodyCommand>(Arena*);
template<> ::sim_msg::Control_ChassisCommand* Arena::CreateMaybeMessage<::sim_msg::Control_ChassisCommand>(Arena*);
template<> ::sim_msg::Control_PedalControl* Arena::CreateMaybeMessage<::sim_msg::Control_PedalControl>(Arena*);
template<> ::sim_msg::Control_PowerTrainCommand* Arena::CreateMaybeMessage<::sim_msg::Control_PowerTrainCommand>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sim_msg {

enum Control_CONTROL_MODE : int {
  Control_CONTROL_MODE_CM_MANUAL = 0,
  Control_CONTROL_MODE_CM_AUTO_DRIVE = 1,
  Control_CONTROL_MODE_CM_ONLY_STEER = 2,
  Control_CONTROL_MODE_CM_ONLY_SPEED = 3,
  Control_CONTROL_MODE_Control_CONTROL_MODE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Control_CONTROL_MODE_Control_CONTROL_MODE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Control_CONTROL_MODE_IsValid(int value);
constexpr Control_CONTROL_MODE Control_CONTROL_MODE_CONTROL_MODE_MIN = Control_CONTROL_MODE_CM_MANUAL;
constexpr Control_CONTROL_MODE Control_CONTROL_MODE_CONTROL_MODE_MAX = Control_CONTROL_MODE_CM_ONLY_SPEED;
constexpr int Control_CONTROL_MODE_CONTROL_MODE_ARRAYSIZE = Control_CONTROL_MODE_CONTROL_MODE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Control_CONTROL_MODE_descriptor();
template<typename T>
inline const std::string& Control_CONTROL_MODE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Control_CONTROL_MODE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Control_CONTROL_MODE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Control_CONTROL_MODE_descriptor(), enum_t_value);
}
inline bool Control_CONTROL_MODE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Control_CONTROL_MODE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Control_CONTROL_MODE>(
    Control_CONTROL_MODE_descriptor(), name, value);
}
enum Control_GEAR_MODE : int {
  Control_GEAR_MODE_NO_CONTROL = 0,
  Control_GEAR_MODE_PARK = 1,
  Control_GEAR_MODE_REVERSE = 2,
  Control_GEAR_MODE_NEUTRAL = 3,
  Control_GEAR_MODE_DRIVE = 4,
  Control_GEAR_MODE_Control_GEAR_MODE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Control_GEAR_MODE_Control_GEAR_MODE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Control_GEAR_MODE_IsValid(int value);
constexpr Control_GEAR_MODE Control_GEAR_MODE_GEAR_MODE_MIN = Control_GEAR_MODE_NO_CONTROL;
constexpr Control_GEAR_MODE Control_GEAR_MODE_GEAR_MODE_MAX = Control_GEAR_MODE_DRIVE;
constexpr int Control_GEAR_MODE_GEAR_MODE_ARRAYSIZE = Control_GEAR_MODE_GEAR_MODE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Control_GEAR_MODE_descriptor();
template<typename T>
inline const std::string& Control_GEAR_MODE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Control_GEAR_MODE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Control_GEAR_MODE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Control_GEAR_MODE_descriptor(), enum_t_value);
}
inline bool Control_GEAR_MODE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Control_GEAR_MODE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Control_GEAR_MODE>(
    Control_GEAR_MODE_descriptor(), name, value);
}
enum Control_CONTROL_TYPE : int {
  Control_CONTROL_TYPE_PEDAL_CONTROL = 0,
  Control_CONTROL_TYPE_ACC_CONTROL = 1,
  Control_CONTROL_TYPE_ACC_STEER_CONTROL = 2,
  Control_CONTROL_TYPE_Control_CONTROL_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Control_CONTROL_TYPE_Control_CONTROL_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Control_CONTROL_TYPE_IsValid(int value);
constexpr Control_CONTROL_TYPE Control_CONTROL_TYPE_CONTROL_TYPE_MIN = Control_CONTROL_TYPE_PEDAL_CONTROL;
constexpr Control_CONTROL_TYPE Control_CONTROL_TYPE_CONTROL_TYPE_MAX = Control_CONTROL_TYPE_ACC_STEER_CONTROL;
constexpr int Control_CONTROL_TYPE_CONTROL_TYPE_ARRAYSIZE = Control_CONTROL_TYPE_CONTROL_TYPE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Control_CONTROL_TYPE_descriptor();
template<typename T>
inline const std::string& Control_CONTROL_TYPE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Control_CONTROL_TYPE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Control_CONTROL_TYPE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Control_CONTROL_TYPE_descriptor(), enum_t_value);
}
inline bool Control_CONTROL_TYPE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Control_CONTROL_TYPE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Control_CONTROL_TYPE>(
    Control_CONTROL_TYPE_descriptor(), name, value);
}
enum Control_TurnLight : int {
  Control_TurnLight_TURN_LIGHT_OFF = 0,
  Control_TurnLight_TURN_LEFT = 1,
  Control_TurnLight_TURN_RIGHT = 2,
  Control_TurnLight_Control_TurnLight_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Control_TurnLight_Control_TurnLight_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Control_TurnLight_IsValid(int value);
constexpr Control_TurnLight Control_TurnLight_TurnLight_MIN = Control_TurnLight_TURN_LIGHT_OFF;
constexpr Control_TurnLight Control_TurnLight_TurnLight_MAX = Control_TurnLight_TURN_RIGHT;
constexpr int Control_TurnLight_TurnLight_ARRAYSIZE = Control_TurnLight_TurnLight_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Control_TurnLight_descriptor();
template<typename T>
inline const std::string& Control_TurnLight_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Control_TurnLight>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Control_TurnLight_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Control_TurnLight_descriptor(), enum_t_value);
}
inline bool Control_TurnLight_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Control_TurnLight* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Control_TurnLight>(
    Control_TurnLight_descriptor(), name, value);
}
enum Control_FogLamp : int {
  Control_FogLamp_FOG_LAMP_OFF = 0,
  Control_FogLamp_FRONT_FOG_LAMP = 1,
  Control_FogLamp_REAR_FOG_LAMP = 2,
  Control_FogLamp_ALL_FOG_LAMP = 3,
  Control_FogLamp_Control_FogLamp_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Control_FogLamp_Control_FogLamp_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Control_FogLamp_IsValid(int value);
constexpr Control_FogLamp Control_FogLamp_FogLamp_MIN = Control_FogLamp_FOG_LAMP_OFF;
constexpr Control_FogLamp Control_FogLamp_FogLamp_MAX = Control_FogLamp_ALL_FOG_LAMP;
constexpr int Control_FogLamp_FogLamp_ARRAYSIZE = Control_FogLamp_FogLamp_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Control_FogLamp_descriptor();
template<typename T>
inline const std::string& Control_FogLamp_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Control_FogLamp>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Control_FogLamp_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Control_FogLamp_descriptor(), enum_t_value);
}
inline bool Control_FogLamp_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Control_FogLamp* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Control_FogLamp>(
    Control_FogLamp_descriptor(), name, value);
}
// ===================================================================

class Control_PedalControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.PedalControl) */ {
 public:
  inline Control_PedalControl() : Control_PedalControl(nullptr) {}
  ~Control_PedalControl() override;
  explicit constexpr Control_PedalControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Control_PedalControl(const Control_PedalControl& from);
  Control_PedalControl(Control_PedalControl&& from) noexcept
    : Control_PedalControl() {
    *this = ::std::move(from);
  }

  inline Control_PedalControl& operator=(const Control_PedalControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control_PedalControl& operator=(Control_PedalControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control_PedalControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control_PedalControl* internal_default_instance() {
    return reinterpret_cast<const Control_PedalControl*>(
               &_Control_PedalControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Control_PedalControl& a, Control_PedalControl& b) {
    a.Swap(&b);
  }
  inline void Swap(Control_PedalControl* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control_PedalControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Control_PedalControl* New() const final {
    return new Control_PedalControl();
  }

  Control_PedalControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Control_PedalControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Control_PedalControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Control_PedalControl& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control_PedalControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Control.PedalControl";
  }
  protected:
  explicit Control_PedalControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteerFieldNumber = 1,
    kThrottleFieldNumber = 2,
    kBrakeFieldNumber = 3,
  };
  // double steer = 1;
  void clear_steer();
  double steer() const;
  void set_steer(double value);
  private:
  double _internal_steer() const;
  void _internal_set_steer(double value);
  public:

  // double throttle = 2;
  void clear_throttle();
  double throttle() const;
  void set_throttle(double value);
  private:
  double _internal_throttle() const;
  void _internal_set_throttle(double value);
  public:

  // double brake = 3;
  void clear_brake();
  double brake() const;
  void set_brake(double value);
  private:
  double _internal_brake() const;
  void _internal_set_brake(double value);
  public:

  // @@protoc_insertion_point(class_scope:sim_msg.Control.PedalControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double steer_;
  double throttle_;
  double brake_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class Control_AccControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.AccControl) */ {
 public:
  inline Control_AccControl() : Control_AccControl(nullptr) {}
  ~Control_AccControl() override;
  explicit constexpr Control_AccControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Control_AccControl(const Control_AccControl& from);
  Control_AccControl(Control_AccControl&& from) noexcept
    : Control_AccControl() {
    *this = ::std::move(from);
  }

  inline Control_AccControl& operator=(const Control_AccControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control_AccControl& operator=(Control_AccControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control_AccControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control_AccControl* internal_default_instance() {
    return reinterpret_cast<const Control_AccControl*>(
               &_Control_AccControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Control_AccControl& a, Control_AccControl& b) {
    a.Swap(&b);
  }
  inline void Swap(Control_AccControl* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control_AccControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Control_AccControl* New() const final {
    return new Control_AccControl();
  }

  Control_AccControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Control_AccControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Control_AccControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Control_AccControl& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control_AccControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Control.AccControl";
  }
  protected:
  explicit Control_AccControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccFieldNumber = 1,
    kFrontWheelAngleFieldNumber = 2,
  };
  // double acc = 1;
  void clear_acc();
  double acc() const;
  void set_acc(double value);
  private:
  double _internal_acc() const;
  void _internal_set_acc(double value);
  public:

  // double front_wheel_angle = 2;
  void clear_front_wheel_angle();
  double front_wheel_angle() const;
  void set_front_wheel_angle(double value);
  private:
  double _internal_front_wheel_angle() const;
  void _internal_set_front_wheel_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:sim_msg.Control.AccControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double acc_;
  double front_wheel_angle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class Control_AccSteerControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.AccSteerControl) */ {
 public:
  inline Control_AccSteerControl() : Control_AccSteerControl(nullptr) {}
  ~Control_AccSteerControl() override;
  explicit constexpr Control_AccSteerControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Control_AccSteerControl(const Control_AccSteerControl& from);
  Control_AccSteerControl(Control_AccSteerControl&& from) noexcept
    : Control_AccSteerControl() {
    *this = ::std::move(from);
  }

  inline Control_AccSteerControl& operator=(const Control_AccSteerControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control_AccSteerControl& operator=(Control_AccSteerControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control_AccSteerControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control_AccSteerControl* internal_default_instance() {
    return reinterpret_cast<const Control_AccSteerControl*>(
               &_Control_AccSteerControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Control_AccSteerControl& a, Control_AccSteerControl& b) {
    a.Swap(&b);
  }
  inline void Swap(Control_AccSteerControl* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control_AccSteerControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Control_AccSteerControl* New() const final {
    return new Control_AccSteerControl();
  }

  Control_AccSteerControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Control_AccSteerControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Control_AccSteerControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Control_AccSteerControl& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control_AccSteerControl* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Control.AccSteerControl";
  }
  protected:
  explicit Control_AccSteerControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccFieldNumber = 1,
    kSteerFieldNumber = 2,
  };
  // double acc = 1;
  void clear_acc();
  double acc() const;
  void set_acc(double value);
  private:
  double _internal_acc() const;
  void _internal_set_acc(double value);
  public:

  // double steer = 2;
  void clear_steer();
  double steer() const;
  void set_steer(double value);
  private:
  double _internal_steer() const;
  void _internal_set_steer(double value);
  public:

  // @@protoc_insertion_point(class_scope:sim_msg.Control.AccSteerControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double acc_;
  double steer_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class Control_BodyCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.BodyCommand) */ {
 public:
  inline Control_BodyCommand() : Control_BodyCommand(nullptr) {}
  ~Control_BodyCommand() override;
  explicit constexpr Control_BodyCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Control_BodyCommand(const Control_BodyCommand& from);
  Control_BodyCommand(Control_BodyCommand&& from) noexcept
    : Control_BodyCommand() {
    *this = ::std::move(from);
  }

  inline Control_BodyCommand& operator=(const Control_BodyCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control_BodyCommand& operator=(Control_BodyCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control_BodyCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control_BodyCommand* internal_default_instance() {
    return reinterpret_cast<const Control_BodyCommand*>(
               &_Control_BodyCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Control_BodyCommand& a, Control_BodyCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(Control_BodyCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control_BodyCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Control_BodyCommand* New() const final {
    return new Control_BodyCommand();
  }

  Control_BodyCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Control_BodyCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Control_BodyCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Control_BodyCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control_BodyCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Control.BodyCommand";
  }
  protected:
  explicit Control_BodyCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTurnLightFieldNumber = 2,
    kHornFieldNumber = 1,
    kPositionLampFieldNumber = 3,
    kLowBeamFieldNumber = 4,
    kHighBeamFieldNumber = 5,
    kWarnLightFieldNumber = 6,
    kFogLampFieldNumber = 7,
  };
  // .sim_msg.Control.TurnLight turn_light = 2;
  void clear_turn_light();
  ::sim_msg::Control_TurnLight turn_light() const;
  void set_turn_light(::sim_msg::Control_TurnLight value);
  private:
  ::sim_msg::Control_TurnLight _internal_turn_light() const;
  void _internal_set_turn_light(::sim_msg::Control_TurnLight value);
  public:

  // bool horn = 1;
  void clear_horn();
  bool horn() const;
  void set_horn(bool value);
  private:
  bool _internal_horn() const;
  void _internal_set_horn(bool value);
  public:

  // bool position_lamp = 3;
  void clear_position_lamp();
  bool position_lamp() const;
  void set_position_lamp(bool value);
  private:
  bool _internal_position_lamp() const;
  void _internal_set_position_lamp(bool value);
  public:

  // bool low_beam = 4;
  void clear_low_beam();
  bool low_beam() const;
  void set_low_beam(bool value);
  private:
  bool _internal_low_beam() const;
  void _internal_set_low_beam(bool value);
  public:

  // bool high_beam = 5;
  void clear_high_beam();
  bool high_beam() const;
  void set_high_beam(bool value);
  private:
  bool _internal_high_beam() const;
  void _internal_set_high_beam(bool value);
  public:

  // bool warn_light = 6;
  void clear_warn_light();
  bool warn_light() const;
  void set_warn_light(bool value);
  private:
  bool _internal_warn_light() const;
  void _internal_set_warn_light(bool value);
  public:

  // .sim_msg.Control.FogLamp fog_lamp = 7;
  void clear_fog_lamp();
  ::sim_msg::Control_FogLamp fog_lamp() const;
  void set_fog_lamp(::sim_msg::Control_FogLamp value);
  private:
  ::sim_msg::Control_FogLamp _internal_fog_lamp() const;
  void _internal_set_fog_lamp(::sim_msg::Control_FogLamp value);
  public:

  // @@protoc_insertion_point(class_scope:sim_msg.Control.BodyCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int turn_light_;
  bool horn_;
  bool position_lamp_;
  bool low_beam_;
  bool high_beam_;
  bool warn_light_;
  int fog_lamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class Control_ChassisCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.ChassisCommand) */ {
 public:
  inline Control_ChassisCommand() : Control_ChassisCommand(nullptr) {}
  ~Control_ChassisCommand() override;
  explicit constexpr Control_ChassisCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Control_ChassisCommand(const Control_ChassisCommand& from);
  Control_ChassisCommand(Control_ChassisCommand&& from) noexcept
    : Control_ChassisCommand() {
    *this = ::std::move(from);
  }

  inline Control_ChassisCommand& operator=(const Control_ChassisCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control_ChassisCommand& operator=(Control_ChassisCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control_ChassisCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control_ChassisCommand* internal_default_instance() {
    return reinterpret_cast<const Control_ChassisCommand*>(
               &_Control_ChassisCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Control_ChassisCommand& a, Control_ChassisCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(Control_ChassisCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control_ChassisCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Control_ChassisCommand* New() const final {
    return new Control_ChassisCommand();
  }

  Control_ChassisCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Control_ChassisCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Control_ChassisCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Control_ChassisCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control_ChassisCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Control.ChassisCommand";
  }
  protected:
  explicit Control_ChassisCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEpbFieldNumber = 1,
  };
  // bool epb = 1;
  void clear_epb();
  bool epb() const;
  void set_epb(bool value);
  private:
  bool _internal_epb() const;
  void _internal_set_epb(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sim_msg.Control.ChassisCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool epb_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class Control_PowerTrainCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control.PowerTrainCommand) */ {
 public:
  inline Control_PowerTrainCommand() : Control_PowerTrainCommand(nullptr) {}
  ~Control_PowerTrainCommand() override;
  explicit constexpr Control_PowerTrainCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Control_PowerTrainCommand(const Control_PowerTrainCommand& from);
  Control_PowerTrainCommand(Control_PowerTrainCommand&& from) noexcept
    : Control_PowerTrainCommand() {
    *this = ::std::move(from);
  }

  inline Control_PowerTrainCommand& operator=(const Control_PowerTrainCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control_PowerTrainCommand& operator=(Control_PowerTrainCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control_PowerTrainCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control_PowerTrainCommand* internal_default_instance() {
    return reinterpret_cast<const Control_PowerTrainCommand*>(
               &_Control_PowerTrainCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Control_PowerTrainCommand& a, Control_PowerTrainCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(Control_PowerTrainCommand* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control_PowerTrainCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Control_PowerTrainCommand* New() const final {
    return new Control_PowerTrainCommand();
  }

  Control_PowerTrainCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Control_PowerTrainCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Control_PowerTrainCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Control_PowerTrainCommand& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control_PowerTrainCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Control.PowerTrainCommand";
  }
  protected:
  explicit Control_PowerTrainCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSwitchOffEngineFieldNumber = 1,
  };
  // bool switch_off_engine = 1;
  void clear_switch_off_engine();
  bool switch_off_engine() const;
  void set_switch_off_engine(bool value);
  private:
  bool _internal_switch_off_engine() const;
  void _internal_set_switch_off_engine(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sim_msg.Control.PowerTrainCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool switch_off_engine_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class Control final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.Control) */ {
 public:
  inline Control() : Control(nullptr) {}
  ~Control() override;
  explicit constexpr Control(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Control(const Control& from);
  Control(Control&& from) noexcept
    : Control() {
    *this = ::std::move(from);
  }

  inline Control& operator=(const Control& from) {
    CopyFrom(from);
    return *this;
  }
  inline Control& operator=(Control&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Control& default_instance() {
    return *internal_default_instance();
  }
  static inline const Control* internal_default_instance() {
    return reinterpret_cast<const Control*>(
               &_Control_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Control& a, Control& b) {
    a.Swap(&b);
  }
  inline void Swap(Control* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Control* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Control* New() const final {
    return new Control();
  }

  Control* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Control>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Control& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Control& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Control* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.Control";
  }
  protected:
  explicit Control(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Control_PedalControl PedalControl;
  typedef Control_AccControl AccControl;
  typedef Control_AccSteerControl AccSteerControl;
  typedef Control_BodyCommand BodyCommand;
  typedef Control_ChassisCommand ChassisCommand;
  typedef Control_PowerTrainCommand PowerTrainCommand;

  typedef Control_CONTROL_MODE CONTROL_MODE;
  static constexpr CONTROL_MODE CM_MANUAL =
    Control_CONTROL_MODE_CM_MANUAL;
  static constexpr CONTROL_MODE CM_AUTO_DRIVE =
    Control_CONTROL_MODE_CM_AUTO_DRIVE;
  static constexpr CONTROL_MODE CM_ONLY_STEER =
    Control_CONTROL_MODE_CM_ONLY_STEER;
  static constexpr CONTROL_MODE CM_ONLY_SPEED =
    Control_CONTROL_MODE_CM_ONLY_SPEED;
  static inline bool CONTROL_MODE_IsValid(int value) {
    return Control_CONTROL_MODE_IsValid(value);
  }
  static constexpr CONTROL_MODE CONTROL_MODE_MIN =
    Control_CONTROL_MODE_CONTROL_MODE_MIN;
  static constexpr CONTROL_MODE CONTROL_MODE_MAX =
    Control_CONTROL_MODE_CONTROL_MODE_MAX;
  static constexpr int CONTROL_MODE_ARRAYSIZE =
    Control_CONTROL_MODE_CONTROL_MODE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CONTROL_MODE_descriptor() {
    return Control_CONTROL_MODE_descriptor();
  }
  template<typename T>
  static inline const std::string& CONTROL_MODE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CONTROL_MODE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CONTROL_MODE_Name.");
    return Control_CONTROL_MODE_Name(enum_t_value);
  }
  static inline bool CONTROL_MODE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CONTROL_MODE* value) {
    return Control_CONTROL_MODE_Parse(name, value);
  }

  typedef Control_GEAR_MODE GEAR_MODE;
  static constexpr GEAR_MODE NO_CONTROL =
    Control_GEAR_MODE_NO_CONTROL;
  static constexpr GEAR_MODE PARK =
    Control_GEAR_MODE_PARK;
  static constexpr GEAR_MODE REVERSE =
    Control_GEAR_MODE_REVERSE;
  static constexpr GEAR_MODE NEUTRAL =
    Control_GEAR_MODE_NEUTRAL;
  static constexpr GEAR_MODE DRIVE =
    Control_GEAR_MODE_DRIVE;
  static inline bool GEAR_MODE_IsValid(int value) {
    return Control_GEAR_MODE_IsValid(value);
  }
  static constexpr GEAR_MODE GEAR_MODE_MIN =
    Control_GEAR_MODE_GEAR_MODE_MIN;
  static constexpr GEAR_MODE GEAR_MODE_MAX =
    Control_GEAR_MODE_GEAR_MODE_MAX;
  static constexpr int GEAR_MODE_ARRAYSIZE =
    Control_GEAR_MODE_GEAR_MODE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  GEAR_MODE_descriptor() {
    return Control_GEAR_MODE_descriptor();
  }
  template<typename T>
  static inline const std::string& GEAR_MODE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, GEAR_MODE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function GEAR_MODE_Name.");
    return Control_GEAR_MODE_Name(enum_t_value);
  }
  static inline bool GEAR_MODE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      GEAR_MODE* value) {
    return Control_GEAR_MODE_Parse(name, value);
  }

  typedef Control_CONTROL_TYPE CONTROL_TYPE;
  static constexpr CONTROL_TYPE PEDAL_CONTROL =
    Control_CONTROL_TYPE_PEDAL_CONTROL;
  static constexpr CONTROL_TYPE ACC_CONTROL =
    Control_CONTROL_TYPE_ACC_CONTROL;
  static constexpr CONTROL_TYPE ACC_STEER_CONTROL =
    Control_CONTROL_TYPE_ACC_STEER_CONTROL;
  static inline bool CONTROL_TYPE_IsValid(int value) {
    return Control_CONTROL_TYPE_IsValid(value);
  }
  static constexpr CONTROL_TYPE CONTROL_TYPE_MIN =
    Control_CONTROL_TYPE_CONTROL_TYPE_MIN;
  static constexpr CONTROL_TYPE CONTROL_TYPE_MAX =
    Control_CONTROL_TYPE_CONTROL_TYPE_MAX;
  static constexpr int CONTROL_TYPE_ARRAYSIZE =
    Control_CONTROL_TYPE_CONTROL_TYPE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CONTROL_TYPE_descriptor() {
    return Control_CONTROL_TYPE_descriptor();
  }
  template<typename T>
  static inline const std::string& CONTROL_TYPE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CONTROL_TYPE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CONTROL_TYPE_Name.");
    return Control_CONTROL_TYPE_Name(enum_t_value);
  }
  static inline bool CONTROL_TYPE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CONTROL_TYPE* value) {
    return Control_CONTROL_TYPE_Parse(name, value);
  }

  typedef Control_TurnLight TurnLight;
  static constexpr TurnLight TURN_LIGHT_OFF =
    Control_TurnLight_TURN_LIGHT_OFF;
  static constexpr TurnLight TURN_LEFT =
    Control_TurnLight_TURN_LEFT;
  static constexpr TurnLight TURN_RIGHT =
    Control_TurnLight_TURN_RIGHT;
  static inline bool TurnLight_IsValid(int value) {
    return Control_TurnLight_IsValid(value);
  }
  static constexpr TurnLight TurnLight_MIN =
    Control_TurnLight_TurnLight_MIN;
  static constexpr TurnLight TurnLight_MAX =
    Control_TurnLight_TurnLight_MAX;
  static constexpr int TurnLight_ARRAYSIZE =
    Control_TurnLight_TurnLight_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TurnLight_descriptor() {
    return Control_TurnLight_descriptor();
  }
  template<typename T>
  static inline const std::string& TurnLight_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TurnLight>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TurnLight_Name.");
    return Control_TurnLight_Name(enum_t_value);
  }
  static inline bool TurnLight_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TurnLight* value) {
    return Control_TurnLight_Parse(name, value);
  }

  typedef Control_FogLamp FogLamp;
  static constexpr FogLamp FOG_LAMP_OFF =
    Control_FogLamp_FOG_LAMP_OFF;
  static constexpr FogLamp FRONT_FOG_LAMP =
    Control_FogLamp_FRONT_FOG_LAMP;
  static constexpr FogLamp REAR_FOG_LAMP =
    Control_FogLamp_REAR_FOG_LAMP;
  static constexpr FogLamp ALL_FOG_LAMP =
    Control_FogLamp_ALL_FOG_LAMP;
  static inline bool FogLamp_IsValid(int value) {
    return Control_FogLamp_IsValid(value);
  }
  static constexpr FogLamp FogLamp_MIN =
    Control_FogLamp_FogLamp_MIN;
  static constexpr FogLamp FogLamp_MAX =
    Control_FogLamp_FogLamp_MAX;
  static constexpr int FogLamp_ARRAYSIZE =
    Control_FogLamp_FogLamp_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FogLamp_descriptor() {
    return Control_FogLamp_descriptor();
  }
  template<typename T>
  static inline const std::string& FogLamp_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FogLamp>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FogLamp_Name.");
    return Control_FogLamp_Name(enum_t_value);
  }
  static inline bool FogLamp_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FogLamp* value) {
    return Control_FogLamp_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kPedalCmdFieldNumber = 5,
    kAccCmdFieldNumber = 6,
    kBodyCmdFieldNumber = 7,
    kChassisCmdFieldNumber = 8,
    kPowertrainCmdFieldNumber = 9,
    kAccSteerCmdFieldNumber = 10,
    kControlModeFieldNumber = 2,
    kContrlTypeFieldNumber = 3,
    kGearCmdFieldNumber = 4,
  };
  // .sim_msg.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::sim_msg::Header& header() const;
  PROTOBUF_MUST_USE_RESULT ::sim_msg::Header* release_header();
  ::sim_msg::Header* mutable_header();
  void set_allocated_header(::sim_msg::Header* header);
  private:
  const ::sim_msg::Header& _internal_header() const;
  ::sim_msg::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::sim_msg::Header* header);
  ::sim_msg::Header* unsafe_arena_release_header();

  // .sim_msg.Control.PedalControl pedal_cmd = 5;
  bool has_pedal_cmd() const;
  private:
  bool _internal_has_pedal_cmd() const;
  public:
  void clear_pedal_cmd();
  const ::sim_msg::Control_PedalControl& pedal_cmd() const;
  PROTOBUF_MUST_USE_RESULT ::sim_msg::Control_PedalControl* release_pedal_cmd();
  ::sim_msg::Control_PedalControl* mutable_pedal_cmd();
  void set_allocated_pedal_cmd(::sim_msg::Control_PedalControl* pedal_cmd);
  private:
  const ::sim_msg::Control_PedalControl& _internal_pedal_cmd() const;
  ::sim_msg::Control_PedalControl* _internal_mutable_pedal_cmd();
  public:
  void unsafe_arena_set_allocated_pedal_cmd(
      ::sim_msg::Control_PedalControl* pedal_cmd);
  ::sim_msg::Control_PedalControl* unsafe_arena_release_pedal_cmd();

  // .sim_msg.Control.AccControl acc_cmd = 6;
  bool has_acc_cmd() const;
  private:
  bool _internal_has_acc_cmd() const;
  public:
  void clear_acc_cmd();
  const ::sim_msg::Control_AccControl& acc_cmd() const;
  PROTOBUF_MUST_USE_RESULT ::sim_msg::Control_AccControl* release_acc_cmd();
  ::sim_msg::Control_AccControl* mutable_acc_cmd();
  void set_allocated_acc_cmd(::sim_msg::Control_AccControl* acc_cmd);
  private:
  const ::sim_msg::Control_AccControl& _internal_acc_cmd() const;
  ::sim_msg::Control_AccControl* _internal_mutable_acc_cmd();
  public:
  void unsafe_arena_set_allocated_acc_cmd(
      ::sim_msg::Control_AccControl* acc_cmd);
  ::sim_msg::Control_AccControl* unsafe_arena_release_acc_cmd();

  // .sim_msg.Control.BodyCommand body_cmd = 7;
  bool has_body_cmd() const;
  private:
  bool _internal_has_body_cmd() const;
  public:
  void clear_body_cmd();
  const ::sim_msg::Control_BodyCommand& body_cmd() const;
  PROTOBUF_MUST_USE_RESULT ::sim_msg::Control_BodyCommand* release_body_cmd();
  ::sim_msg::Control_BodyCommand* mutable_body_cmd();
  void set_allocated_body_cmd(::sim_msg::Control_BodyCommand* body_cmd);
  private:
  const ::sim_msg::Control_BodyCommand& _internal_body_cmd() const;
  ::sim_msg::Control_BodyCommand* _internal_mutable_body_cmd();
  public:
  void unsafe_arena_set_allocated_body_cmd(
      ::sim_msg::Control_BodyCommand* body_cmd);
  ::sim_msg::Control_BodyCommand* unsafe_arena_release_body_cmd();

  // .sim_msg.Control.ChassisCommand chassis_cmd = 8;
  bool has_chassis_cmd() const;
  private:
  bool _internal_has_chassis_cmd() const;
  public:
  void clear_chassis_cmd();
  const ::sim_msg::Control_ChassisCommand& chassis_cmd() const;
  PROTOBUF_MUST_USE_RESULT ::sim_msg::Control_ChassisCommand* release_chassis_cmd();
  ::sim_msg::Control_ChassisCommand* mutable_chassis_cmd();
  void set_allocated_chassis_cmd(::sim_msg::Control_ChassisCommand* chassis_cmd);
  private:
  const ::sim_msg::Control_ChassisCommand& _internal_chassis_cmd() const;
  ::sim_msg::Control_ChassisCommand* _internal_mutable_chassis_cmd();
  public:
  void unsafe_arena_set_allocated_chassis_cmd(
      ::sim_msg::Control_ChassisCommand* chassis_cmd);
  ::sim_msg::Control_ChassisCommand* unsafe_arena_release_chassis_cmd();

  // .sim_msg.Control.PowerTrainCommand powertrain_cmd = 9;
  bool has_powertrain_cmd() const;
  private:
  bool _internal_has_powertrain_cmd() const;
  public:
  void clear_powertrain_cmd();
  const ::sim_msg::Control_PowerTrainCommand& powertrain_cmd() const;
  PROTOBUF_MUST_USE_RESULT ::sim_msg::Control_PowerTrainCommand* release_powertrain_cmd();
  ::sim_msg::Control_PowerTrainCommand* mutable_powertrain_cmd();
  void set_allocated_powertrain_cmd(::sim_msg::Control_PowerTrainCommand* powertrain_cmd);
  private:
  const ::sim_msg::Control_PowerTrainCommand& _internal_powertrain_cmd() const;
  ::sim_msg::Control_PowerTrainCommand* _internal_mutable_powertrain_cmd();
  public:
  void unsafe_arena_set_allocated_powertrain_cmd(
      ::sim_msg::Control_PowerTrainCommand* powertrain_cmd);
  ::sim_msg::Control_PowerTrainCommand* unsafe_arena_release_powertrain_cmd();

  // .sim_msg.Control.AccSteerControl acc_steer_cmd = 10;
  bool has_acc_steer_cmd() const;
  private:
  bool _internal_has_acc_steer_cmd() const;
  public:
  void clear_acc_steer_cmd();
  const ::sim_msg::Control_AccSteerControl& acc_steer_cmd() const;
  PROTOBUF_MUST_USE_RESULT ::sim_msg::Control_AccSteerControl* release_acc_steer_cmd();
  ::sim_msg::Control_AccSteerControl* mutable_acc_steer_cmd();
  void set_allocated_acc_steer_cmd(::sim_msg::Control_AccSteerControl* acc_steer_cmd);
  private:
  const ::sim_msg::Control_AccSteerControl& _internal_acc_steer_cmd() const;
  ::sim_msg::Control_AccSteerControl* _internal_mutable_acc_steer_cmd();
  public:
  void unsafe_arena_set_allocated_acc_steer_cmd(
      ::sim_msg::Control_AccSteerControl* acc_steer_cmd);
  ::sim_msg::Control_AccSteerControl* unsafe_arena_release_acc_steer_cmd();

  // .sim_msg.Control.CONTROL_MODE control_mode = 2;
  void clear_control_mode();
  ::sim_msg::Control_CONTROL_MODE control_mode() const;
  void set_control_mode(::sim_msg::Control_CONTROL_MODE value);
  private:
  ::sim_msg::Control_CONTROL_MODE _internal_control_mode() const;
  void _internal_set_control_mode(::sim_msg::Control_CONTROL_MODE value);
  public:

  // .sim_msg.Control.CONTROL_TYPE contrl_type = 3;
  void clear_contrl_type();
  ::sim_msg::Control_CONTROL_TYPE contrl_type() const;
  void set_contrl_type(::sim_msg::Control_CONTROL_TYPE value);
  private:
  ::sim_msg::Control_CONTROL_TYPE _internal_contrl_type() const;
  void _internal_set_contrl_type(::sim_msg::Control_CONTROL_TYPE value);
  public:

  // .sim_msg.Control.GEAR_MODE gear_cmd = 4;
  void clear_gear_cmd();
  ::sim_msg::Control_GEAR_MODE gear_cmd() const;
  void set_gear_cmd(::sim_msg::Control_GEAR_MODE value);
  private:
  ::sim_msg::Control_GEAR_MODE _internal_gear_cmd() const;
  void _internal_set_gear_cmd(::sim_msg::Control_GEAR_MODE value);
  public:

  // @@protoc_insertion_point(class_scope:sim_msg.Control)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::sim_msg::Header* header_;
  ::sim_msg::Control_PedalControl* pedal_cmd_;
  ::sim_msg::Control_AccControl* acc_cmd_;
  ::sim_msg::Control_BodyCommand* body_cmd_;
  ::sim_msg::Control_ChassisCommand* chassis_cmd_;
  ::sim_msg::Control_PowerTrainCommand* powertrain_cmd_;
  ::sim_msg::Control_AccSteerControl* acc_steer_cmd_;
  int control_mode_;
  int contrl_type_;
  int gear_cmd_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// -------------------------------------------------------------------

class ControlSAIC final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sim_msg.ControlSAIC) */ {
 public:
  inline ControlSAIC() : ControlSAIC(nullptr) {}
  ~ControlSAIC() override;
  explicit constexpr ControlSAIC(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ControlSAIC(const ControlSAIC& from);
  ControlSAIC(ControlSAIC&& from) noexcept
    : ControlSAIC() {
    *this = ::std::move(from);
  }

  inline ControlSAIC& operator=(const ControlSAIC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlSAIC& operator=(ControlSAIC&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ControlSAIC& default_instance() {
    return *internal_default_instance();
  }
  static inline const ControlSAIC* internal_default_instance() {
    return reinterpret_cast<const ControlSAIC*>(
               &_ControlSAIC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ControlSAIC& a, ControlSAIC& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlSAIC* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlSAIC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlSAIC* New() const final {
    return new ControlSAIC();
  }

  ControlSAIC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlSAIC>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ControlSAIC& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ControlSAIC& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlSAIC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sim_msg.ControlSAIC";
  }
  protected:
  explicit ControlSAIC(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTorqueReqFieldNumber = 1,
    kSteerReqFieldNumber = 2,
    kBrakePressureReqFieldNumber = 4,
    kAccReqFieldNumber = 5,
    kDriveModeReqFieldNumber = 3,
  };
  // double torqueReq = 1;
  void clear_torquereq();
  double torquereq() const;
  void set_torquereq(double value);
  private:
  double _internal_torquereq() const;
  void _internal_set_torquereq(double value);
  public:

  // double steerReq = 2;
  void clear_steerreq();
  double steerreq() const;
  void set_steerreq(double value);
  private:
  double _internal_steerreq() const;
  void _internal_set_steerreq(double value);
  public:

  // double brakePressureReq = 4;
  void clear_brakepressurereq();
  double brakepressurereq() const;
  void set_brakepressurereq(double value);
  private:
  double _internal_brakepressurereq() const;
  void _internal_set_brakepressurereq(double value);
  public:

  // double accReq = 5;
  void clear_accreq();
  double accreq() const;
  void set_accreq(double value);
  private:
  double _internal_accreq() const;
  void _internal_set_accreq(double value);
  public:

  // int32 driveModeReq = 3;
  void clear_drivemodereq();
  ::PROTOBUF_NAMESPACE_ID::int32 drivemodereq() const;
  void set_drivemodereq(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_drivemodereq() const;
  void _internal_set_drivemodereq(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:sim_msg.ControlSAIC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double torquereq_;
  double steerreq_;
  double brakepressurereq_;
  double accreq_;
  ::PROTOBUF_NAMESPACE_ID::int32 drivemodereq_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_control_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Control_PedalControl

// double steer = 1;
inline void Control_PedalControl::clear_steer() {
  steer_ = 0;
}
inline double Control_PedalControl::_internal_steer() const {
  return steer_;
}
inline double Control_PedalControl::steer() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.PedalControl.steer)
  return _internal_steer();
}
inline void Control_PedalControl::_internal_set_steer(double value) {
  
  steer_ = value;
}
inline void Control_PedalControl::set_steer(double value) {
  _internal_set_steer(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.PedalControl.steer)
}

// double throttle = 2;
inline void Control_PedalControl::clear_throttle() {
  throttle_ = 0;
}
inline double Control_PedalControl::_internal_throttle() const {
  return throttle_;
}
inline double Control_PedalControl::throttle() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.PedalControl.throttle)
  return _internal_throttle();
}
inline void Control_PedalControl::_internal_set_throttle(double value) {
  
  throttle_ = value;
}
inline void Control_PedalControl::set_throttle(double value) {
  _internal_set_throttle(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.PedalControl.throttle)
}

// double brake = 3;
inline void Control_PedalControl::clear_brake() {
  brake_ = 0;
}
inline double Control_PedalControl::_internal_brake() const {
  return brake_;
}
inline double Control_PedalControl::brake() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.PedalControl.brake)
  return _internal_brake();
}
inline void Control_PedalControl::_internal_set_brake(double value) {
  
  brake_ = value;
}
inline void Control_PedalControl::set_brake(double value) {
  _internal_set_brake(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.PedalControl.brake)
}

// -------------------------------------------------------------------

// Control_AccControl

// double acc = 1;
inline void Control_AccControl::clear_acc() {
  acc_ = 0;
}
inline double Control_AccControl::_internal_acc() const {
  return acc_;
}
inline double Control_AccControl::acc() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.AccControl.acc)
  return _internal_acc();
}
inline void Control_AccControl::_internal_set_acc(double value) {
  
  acc_ = value;
}
inline void Control_AccControl::set_acc(double value) {
  _internal_set_acc(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.AccControl.acc)
}

// double front_wheel_angle = 2;
inline void Control_AccControl::clear_front_wheel_angle() {
  front_wheel_angle_ = 0;
}
inline double Control_AccControl::_internal_front_wheel_angle() const {
  return front_wheel_angle_;
}
inline double Control_AccControl::front_wheel_angle() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.AccControl.front_wheel_angle)
  return _internal_front_wheel_angle();
}
inline void Control_AccControl::_internal_set_front_wheel_angle(double value) {
  
  front_wheel_angle_ = value;
}
inline void Control_AccControl::set_front_wheel_angle(double value) {
  _internal_set_front_wheel_angle(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.AccControl.front_wheel_angle)
}

// -------------------------------------------------------------------

// Control_AccSteerControl

// double acc = 1;
inline void Control_AccSteerControl::clear_acc() {
  acc_ = 0;
}
inline double Control_AccSteerControl::_internal_acc() const {
  return acc_;
}
inline double Control_AccSteerControl::acc() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.AccSteerControl.acc)
  return _internal_acc();
}
inline void Control_AccSteerControl::_internal_set_acc(double value) {
  
  acc_ = value;
}
inline void Control_AccSteerControl::set_acc(double value) {
  _internal_set_acc(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.AccSteerControl.acc)
}

// double steer = 2;
inline void Control_AccSteerControl::clear_steer() {
  steer_ = 0;
}
inline double Control_AccSteerControl::_internal_steer() const {
  return steer_;
}
inline double Control_AccSteerControl::steer() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.AccSteerControl.steer)
  return _internal_steer();
}
inline void Control_AccSteerControl::_internal_set_steer(double value) {
  
  steer_ = value;
}
inline void Control_AccSteerControl::set_steer(double value) {
  _internal_set_steer(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.AccSteerControl.steer)
}

// -------------------------------------------------------------------

// Control_BodyCommand

// bool horn = 1;
inline void Control_BodyCommand::clear_horn() {
  horn_ = false;
}
inline bool Control_BodyCommand::_internal_horn() const {
  return horn_;
}
inline bool Control_BodyCommand::horn() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.horn)
  return _internal_horn();
}
inline void Control_BodyCommand::_internal_set_horn(bool value) {
  
  horn_ = value;
}
inline void Control_BodyCommand::set_horn(bool value) {
  _internal_set_horn(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.horn)
}

// .sim_msg.Control.TurnLight turn_light = 2;
inline void Control_BodyCommand::clear_turn_light() {
  turn_light_ = 0;
}
inline ::sim_msg::Control_TurnLight Control_BodyCommand::_internal_turn_light() const {
  return static_cast< ::sim_msg::Control_TurnLight >(turn_light_);
}
inline ::sim_msg::Control_TurnLight Control_BodyCommand::turn_light() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.turn_light)
  return _internal_turn_light();
}
inline void Control_BodyCommand::_internal_set_turn_light(::sim_msg::Control_TurnLight value) {
  
  turn_light_ = value;
}
inline void Control_BodyCommand::set_turn_light(::sim_msg::Control_TurnLight value) {
  _internal_set_turn_light(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.turn_light)
}

// bool position_lamp = 3;
inline void Control_BodyCommand::clear_position_lamp() {
  position_lamp_ = false;
}
inline bool Control_BodyCommand::_internal_position_lamp() const {
  return position_lamp_;
}
inline bool Control_BodyCommand::position_lamp() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.position_lamp)
  return _internal_position_lamp();
}
inline void Control_BodyCommand::_internal_set_position_lamp(bool value) {
  
  position_lamp_ = value;
}
inline void Control_BodyCommand::set_position_lamp(bool value) {
  _internal_set_position_lamp(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.position_lamp)
}

// bool low_beam = 4;
inline void Control_BodyCommand::clear_low_beam() {
  low_beam_ = false;
}
inline bool Control_BodyCommand::_internal_low_beam() const {
  return low_beam_;
}
inline bool Control_BodyCommand::low_beam() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.low_beam)
  return _internal_low_beam();
}
inline void Control_BodyCommand::_internal_set_low_beam(bool value) {
  
  low_beam_ = value;
}
inline void Control_BodyCommand::set_low_beam(bool value) {
  _internal_set_low_beam(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.low_beam)
}

// bool high_beam = 5;
inline void Control_BodyCommand::clear_high_beam() {
  high_beam_ = false;
}
inline bool Control_BodyCommand::_internal_high_beam() const {
  return high_beam_;
}
inline bool Control_BodyCommand::high_beam() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.high_beam)
  return _internal_high_beam();
}
inline void Control_BodyCommand::_internal_set_high_beam(bool value) {
  
  high_beam_ = value;
}
inline void Control_BodyCommand::set_high_beam(bool value) {
  _internal_set_high_beam(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.high_beam)
}

// bool warn_light = 6;
inline void Control_BodyCommand::clear_warn_light() {
  warn_light_ = false;
}
inline bool Control_BodyCommand::_internal_warn_light() const {
  return warn_light_;
}
inline bool Control_BodyCommand::warn_light() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.warn_light)
  return _internal_warn_light();
}
inline void Control_BodyCommand::_internal_set_warn_light(bool value) {
  
  warn_light_ = value;
}
inline void Control_BodyCommand::set_warn_light(bool value) {
  _internal_set_warn_light(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.warn_light)
}

// .sim_msg.Control.FogLamp fog_lamp = 7;
inline void Control_BodyCommand::clear_fog_lamp() {
  fog_lamp_ = 0;
}
inline ::sim_msg::Control_FogLamp Control_BodyCommand::_internal_fog_lamp() const {
  return static_cast< ::sim_msg::Control_FogLamp >(fog_lamp_);
}
inline ::sim_msg::Control_FogLamp Control_BodyCommand::fog_lamp() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.BodyCommand.fog_lamp)
  return _internal_fog_lamp();
}
inline void Control_BodyCommand::_internal_set_fog_lamp(::sim_msg::Control_FogLamp value) {
  
  fog_lamp_ = value;
}
inline void Control_BodyCommand::set_fog_lamp(::sim_msg::Control_FogLamp value) {
  _internal_set_fog_lamp(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.BodyCommand.fog_lamp)
}

// -------------------------------------------------------------------

// Control_ChassisCommand

// bool epb = 1;
inline void Control_ChassisCommand::clear_epb() {
  epb_ = false;
}
inline bool Control_ChassisCommand::_internal_epb() const {
  return epb_;
}
inline bool Control_ChassisCommand::epb() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.ChassisCommand.epb)
  return _internal_epb();
}
inline void Control_ChassisCommand::_internal_set_epb(bool value) {
  
  epb_ = value;
}
inline void Control_ChassisCommand::set_epb(bool value) {
  _internal_set_epb(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.ChassisCommand.epb)
}

// -------------------------------------------------------------------

// Control_PowerTrainCommand

// bool switch_off_engine = 1;
inline void Control_PowerTrainCommand::clear_switch_off_engine() {
  switch_off_engine_ = false;
}
inline bool Control_PowerTrainCommand::_internal_switch_off_engine() const {
  return switch_off_engine_;
}
inline bool Control_PowerTrainCommand::switch_off_engine() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.PowerTrainCommand.switch_off_engine)
  return _internal_switch_off_engine();
}
inline void Control_PowerTrainCommand::_internal_set_switch_off_engine(bool value) {
  
  switch_off_engine_ = value;
}
inline void Control_PowerTrainCommand::set_switch_off_engine(bool value) {
  _internal_set_switch_off_engine(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.PowerTrainCommand.switch_off_engine)
}

// -------------------------------------------------------------------

// Control

// .sim_msg.Header header = 1;
inline bool Control::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool Control::has_header() const {
  return _internal_has_header();
}
inline const ::sim_msg::Header& Control::_internal_header() const {
  const ::sim_msg::Header* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::sim_msg::Header&>(
      ::sim_msg::_Header_default_instance_);
}
inline const ::sim_msg::Header& Control::header() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.header)
  return _internal_header();
}
inline void Control::unsafe_arena_set_allocated_header(
    ::sim_msg::Header* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sim_msg.Control.header)
}
inline ::sim_msg::Header* Control::release_header() {
  
  ::sim_msg::Header* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sim_msg::Header* Control::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.header)
  
  ::sim_msg::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::sim_msg::Header* Control::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Header>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::sim_msg::Header* Control::mutable_header() {
  ::sim_msg::Header* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.header)
  return _msg;
}
inline void Control::set_allocated_header(::sim_msg::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header));
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.header)
}

// .sim_msg.Control.CONTROL_MODE control_mode = 2;
inline void Control::clear_control_mode() {
  control_mode_ = 0;
}
inline ::sim_msg::Control_CONTROL_MODE Control::_internal_control_mode() const {
  return static_cast< ::sim_msg::Control_CONTROL_MODE >(control_mode_);
}
inline ::sim_msg::Control_CONTROL_MODE Control::control_mode() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.control_mode)
  return _internal_control_mode();
}
inline void Control::_internal_set_control_mode(::sim_msg::Control_CONTROL_MODE value) {
  
  control_mode_ = value;
}
inline void Control::set_control_mode(::sim_msg::Control_CONTROL_MODE value) {
  _internal_set_control_mode(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.control_mode)
}

// .sim_msg.Control.CONTROL_TYPE contrl_type = 3;
inline void Control::clear_contrl_type() {
  contrl_type_ = 0;
}
inline ::sim_msg::Control_CONTROL_TYPE Control::_internal_contrl_type() const {
  return static_cast< ::sim_msg::Control_CONTROL_TYPE >(contrl_type_);
}
inline ::sim_msg::Control_CONTROL_TYPE Control::contrl_type() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.contrl_type)
  return _internal_contrl_type();
}
inline void Control::_internal_set_contrl_type(::sim_msg::Control_CONTROL_TYPE value) {
  
  contrl_type_ = value;
}
inline void Control::set_contrl_type(::sim_msg::Control_CONTROL_TYPE value) {
  _internal_set_contrl_type(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.contrl_type)
}

// .sim_msg.Control.GEAR_MODE gear_cmd = 4;
inline void Control::clear_gear_cmd() {
  gear_cmd_ = 0;
}
inline ::sim_msg::Control_GEAR_MODE Control::_internal_gear_cmd() const {
  return static_cast< ::sim_msg::Control_GEAR_MODE >(gear_cmd_);
}
inline ::sim_msg::Control_GEAR_MODE Control::gear_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.gear_cmd)
  return _internal_gear_cmd();
}
inline void Control::_internal_set_gear_cmd(::sim_msg::Control_GEAR_MODE value) {
  
  gear_cmd_ = value;
}
inline void Control::set_gear_cmd(::sim_msg::Control_GEAR_MODE value) {
  _internal_set_gear_cmd(value);
  // @@protoc_insertion_point(field_set:sim_msg.Control.gear_cmd)
}

// .sim_msg.Control.PedalControl pedal_cmd = 5;
inline bool Control::_internal_has_pedal_cmd() const {
  return this != internal_default_instance() && pedal_cmd_ != nullptr;
}
inline bool Control::has_pedal_cmd() const {
  return _internal_has_pedal_cmd();
}
inline void Control::clear_pedal_cmd() {
  if (GetArenaForAllocation() == nullptr && pedal_cmd_ != nullptr) {
    delete pedal_cmd_;
  }
  pedal_cmd_ = nullptr;
}
inline const ::sim_msg::Control_PedalControl& Control::_internal_pedal_cmd() const {
  const ::sim_msg::Control_PedalControl* p = pedal_cmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::sim_msg::Control_PedalControl&>(
      ::sim_msg::_Control_PedalControl_default_instance_);
}
inline const ::sim_msg::Control_PedalControl& Control::pedal_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.pedal_cmd)
  return _internal_pedal_cmd();
}
inline void Control::unsafe_arena_set_allocated_pedal_cmd(
    ::sim_msg::Control_PedalControl* pedal_cmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pedal_cmd_);
  }
  pedal_cmd_ = pedal_cmd;
  if (pedal_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sim_msg.Control.pedal_cmd)
}
inline ::sim_msg::Control_PedalControl* Control::release_pedal_cmd() {
  
  ::sim_msg::Control_PedalControl* temp = pedal_cmd_;
  pedal_cmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sim_msg::Control_PedalControl* Control::unsafe_arena_release_pedal_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.pedal_cmd)
  
  ::sim_msg::Control_PedalControl* temp = pedal_cmd_;
  pedal_cmd_ = nullptr;
  return temp;
}
inline ::sim_msg::Control_PedalControl* Control::_internal_mutable_pedal_cmd() {
  
  if (pedal_cmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Control_PedalControl>(GetArenaForAllocation());
    pedal_cmd_ = p;
  }
  return pedal_cmd_;
}
inline ::sim_msg::Control_PedalControl* Control::mutable_pedal_cmd() {
  ::sim_msg::Control_PedalControl* _msg = _internal_mutable_pedal_cmd();
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.pedal_cmd)
  return _msg;
}
inline void Control::set_allocated_pedal_cmd(::sim_msg::Control_PedalControl* pedal_cmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pedal_cmd_;
  }
  if (pedal_cmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sim_msg::Control_PedalControl>::GetOwningArena(pedal_cmd);
    if (message_arena != submessage_arena) {
      pedal_cmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pedal_cmd, submessage_arena);
    }
    
  } else {
    
  }
  pedal_cmd_ = pedal_cmd;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.pedal_cmd)
}

// .sim_msg.Control.AccControl acc_cmd = 6;
inline bool Control::_internal_has_acc_cmd() const {
  return this != internal_default_instance() && acc_cmd_ != nullptr;
}
inline bool Control::has_acc_cmd() const {
  return _internal_has_acc_cmd();
}
inline void Control::clear_acc_cmd() {
  if (GetArenaForAllocation() == nullptr && acc_cmd_ != nullptr) {
    delete acc_cmd_;
  }
  acc_cmd_ = nullptr;
}
inline const ::sim_msg::Control_AccControl& Control::_internal_acc_cmd() const {
  const ::sim_msg::Control_AccControl* p = acc_cmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::sim_msg::Control_AccControl&>(
      ::sim_msg::_Control_AccControl_default_instance_);
}
inline const ::sim_msg::Control_AccControl& Control::acc_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.acc_cmd)
  return _internal_acc_cmd();
}
inline void Control::unsafe_arena_set_allocated_acc_cmd(
    ::sim_msg::Control_AccControl* acc_cmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc_cmd_);
  }
  acc_cmd_ = acc_cmd;
  if (acc_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sim_msg.Control.acc_cmd)
}
inline ::sim_msg::Control_AccControl* Control::release_acc_cmd() {
  
  ::sim_msg::Control_AccControl* temp = acc_cmd_;
  acc_cmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sim_msg::Control_AccControl* Control::unsafe_arena_release_acc_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.acc_cmd)
  
  ::sim_msg::Control_AccControl* temp = acc_cmd_;
  acc_cmd_ = nullptr;
  return temp;
}
inline ::sim_msg::Control_AccControl* Control::_internal_mutable_acc_cmd() {
  
  if (acc_cmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Control_AccControl>(GetArenaForAllocation());
    acc_cmd_ = p;
  }
  return acc_cmd_;
}
inline ::sim_msg::Control_AccControl* Control::mutable_acc_cmd() {
  ::sim_msg::Control_AccControl* _msg = _internal_mutable_acc_cmd();
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.acc_cmd)
  return _msg;
}
inline void Control::set_allocated_acc_cmd(::sim_msg::Control_AccControl* acc_cmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete acc_cmd_;
  }
  if (acc_cmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sim_msg::Control_AccControl>::GetOwningArena(acc_cmd);
    if (message_arena != submessage_arena) {
      acc_cmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acc_cmd, submessage_arena);
    }
    
  } else {
    
  }
  acc_cmd_ = acc_cmd;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.acc_cmd)
}

// .sim_msg.Control.BodyCommand body_cmd = 7;
inline bool Control::_internal_has_body_cmd() const {
  return this != internal_default_instance() && body_cmd_ != nullptr;
}
inline bool Control::has_body_cmd() const {
  return _internal_has_body_cmd();
}
inline void Control::clear_body_cmd() {
  if (GetArenaForAllocation() == nullptr && body_cmd_ != nullptr) {
    delete body_cmd_;
  }
  body_cmd_ = nullptr;
}
inline const ::sim_msg::Control_BodyCommand& Control::_internal_body_cmd() const {
  const ::sim_msg::Control_BodyCommand* p = body_cmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::sim_msg::Control_BodyCommand&>(
      ::sim_msg::_Control_BodyCommand_default_instance_);
}
inline const ::sim_msg::Control_BodyCommand& Control::body_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.body_cmd)
  return _internal_body_cmd();
}
inline void Control::unsafe_arena_set_allocated_body_cmd(
    ::sim_msg::Control_BodyCommand* body_cmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(body_cmd_);
  }
  body_cmd_ = body_cmd;
  if (body_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sim_msg.Control.body_cmd)
}
inline ::sim_msg::Control_BodyCommand* Control::release_body_cmd() {
  
  ::sim_msg::Control_BodyCommand* temp = body_cmd_;
  body_cmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sim_msg::Control_BodyCommand* Control::unsafe_arena_release_body_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.body_cmd)
  
  ::sim_msg::Control_BodyCommand* temp = body_cmd_;
  body_cmd_ = nullptr;
  return temp;
}
inline ::sim_msg::Control_BodyCommand* Control::_internal_mutable_body_cmd() {
  
  if (body_cmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Control_BodyCommand>(GetArenaForAllocation());
    body_cmd_ = p;
  }
  return body_cmd_;
}
inline ::sim_msg::Control_BodyCommand* Control::mutable_body_cmd() {
  ::sim_msg::Control_BodyCommand* _msg = _internal_mutable_body_cmd();
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.body_cmd)
  return _msg;
}
inline void Control::set_allocated_body_cmd(::sim_msg::Control_BodyCommand* body_cmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete body_cmd_;
  }
  if (body_cmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sim_msg::Control_BodyCommand>::GetOwningArena(body_cmd);
    if (message_arena != submessage_arena) {
      body_cmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, body_cmd, submessage_arena);
    }
    
  } else {
    
  }
  body_cmd_ = body_cmd;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.body_cmd)
}

// .sim_msg.Control.ChassisCommand chassis_cmd = 8;
inline bool Control::_internal_has_chassis_cmd() const {
  return this != internal_default_instance() && chassis_cmd_ != nullptr;
}
inline bool Control::has_chassis_cmd() const {
  return _internal_has_chassis_cmd();
}
inline void Control::clear_chassis_cmd() {
  if (GetArenaForAllocation() == nullptr && chassis_cmd_ != nullptr) {
    delete chassis_cmd_;
  }
  chassis_cmd_ = nullptr;
}
inline const ::sim_msg::Control_ChassisCommand& Control::_internal_chassis_cmd() const {
  const ::sim_msg::Control_ChassisCommand* p = chassis_cmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::sim_msg::Control_ChassisCommand&>(
      ::sim_msg::_Control_ChassisCommand_default_instance_);
}
inline const ::sim_msg::Control_ChassisCommand& Control::chassis_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.chassis_cmd)
  return _internal_chassis_cmd();
}
inline void Control::unsafe_arena_set_allocated_chassis_cmd(
    ::sim_msg::Control_ChassisCommand* chassis_cmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chassis_cmd_);
  }
  chassis_cmd_ = chassis_cmd;
  if (chassis_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sim_msg.Control.chassis_cmd)
}
inline ::sim_msg::Control_ChassisCommand* Control::release_chassis_cmd() {
  
  ::sim_msg::Control_ChassisCommand* temp = chassis_cmd_;
  chassis_cmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sim_msg::Control_ChassisCommand* Control::unsafe_arena_release_chassis_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.chassis_cmd)
  
  ::sim_msg::Control_ChassisCommand* temp = chassis_cmd_;
  chassis_cmd_ = nullptr;
  return temp;
}
inline ::sim_msg::Control_ChassisCommand* Control::_internal_mutable_chassis_cmd() {
  
  if (chassis_cmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Control_ChassisCommand>(GetArenaForAllocation());
    chassis_cmd_ = p;
  }
  return chassis_cmd_;
}
inline ::sim_msg::Control_ChassisCommand* Control::mutable_chassis_cmd() {
  ::sim_msg::Control_ChassisCommand* _msg = _internal_mutable_chassis_cmd();
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.chassis_cmd)
  return _msg;
}
inline void Control::set_allocated_chassis_cmd(::sim_msg::Control_ChassisCommand* chassis_cmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete chassis_cmd_;
  }
  if (chassis_cmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sim_msg::Control_ChassisCommand>::GetOwningArena(chassis_cmd);
    if (message_arena != submessage_arena) {
      chassis_cmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chassis_cmd, submessage_arena);
    }
    
  } else {
    
  }
  chassis_cmd_ = chassis_cmd;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.chassis_cmd)
}

// .sim_msg.Control.PowerTrainCommand powertrain_cmd = 9;
inline bool Control::_internal_has_powertrain_cmd() const {
  return this != internal_default_instance() && powertrain_cmd_ != nullptr;
}
inline bool Control::has_powertrain_cmd() const {
  return _internal_has_powertrain_cmd();
}
inline void Control::clear_powertrain_cmd() {
  if (GetArenaForAllocation() == nullptr && powertrain_cmd_ != nullptr) {
    delete powertrain_cmd_;
  }
  powertrain_cmd_ = nullptr;
}
inline const ::sim_msg::Control_PowerTrainCommand& Control::_internal_powertrain_cmd() const {
  const ::sim_msg::Control_PowerTrainCommand* p = powertrain_cmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::sim_msg::Control_PowerTrainCommand&>(
      ::sim_msg::_Control_PowerTrainCommand_default_instance_);
}
inline const ::sim_msg::Control_PowerTrainCommand& Control::powertrain_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.powertrain_cmd)
  return _internal_powertrain_cmd();
}
inline void Control::unsafe_arena_set_allocated_powertrain_cmd(
    ::sim_msg::Control_PowerTrainCommand* powertrain_cmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(powertrain_cmd_);
  }
  powertrain_cmd_ = powertrain_cmd;
  if (powertrain_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sim_msg.Control.powertrain_cmd)
}
inline ::sim_msg::Control_PowerTrainCommand* Control::release_powertrain_cmd() {
  
  ::sim_msg::Control_PowerTrainCommand* temp = powertrain_cmd_;
  powertrain_cmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sim_msg::Control_PowerTrainCommand* Control::unsafe_arena_release_powertrain_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.powertrain_cmd)
  
  ::sim_msg::Control_PowerTrainCommand* temp = powertrain_cmd_;
  powertrain_cmd_ = nullptr;
  return temp;
}
inline ::sim_msg::Control_PowerTrainCommand* Control::_internal_mutable_powertrain_cmd() {
  
  if (powertrain_cmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Control_PowerTrainCommand>(GetArenaForAllocation());
    powertrain_cmd_ = p;
  }
  return powertrain_cmd_;
}
inline ::sim_msg::Control_PowerTrainCommand* Control::mutable_powertrain_cmd() {
  ::sim_msg::Control_PowerTrainCommand* _msg = _internal_mutable_powertrain_cmd();
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.powertrain_cmd)
  return _msg;
}
inline void Control::set_allocated_powertrain_cmd(::sim_msg::Control_PowerTrainCommand* powertrain_cmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete powertrain_cmd_;
  }
  if (powertrain_cmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sim_msg::Control_PowerTrainCommand>::GetOwningArena(powertrain_cmd);
    if (message_arena != submessage_arena) {
      powertrain_cmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, powertrain_cmd, submessage_arena);
    }
    
  } else {
    
  }
  powertrain_cmd_ = powertrain_cmd;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.powertrain_cmd)
}

// .sim_msg.Control.AccSteerControl acc_steer_cmd = 10;
inline bool Control::_internal_has_acc_steer_cmd() const {
  return this != internal_default_instance() && acc_steer_cmd_ != nullptr;
}
inline bool Control::has_acc_steer_cmd() const {
  return _internal_has_acc_steer_cmd();
}
inline void Control::clear_acc_steer_cmd() {
  if (GetArenaForAllocation() == nullptr && acc_steer_cmd_ != nullptr) {
    delete acc_steer_cmd_;
  }
  acc_steer_cmd_ = nullptr;
}
inline const ::sim_msg::Control_AccSteerControl& Control::_internal_acc_steer_cmd() const {
  const ::sim_msg::Control_AccSteerControl* p = acc_steer_cmd_;
  return p != nullptr ? *p : reinterpret_cast<const ::sim_msg::Control_AccSteerControl&>(
      ::sim_msg::_Control_AccSteerControl_default_instance_);
}
inline const ::sim_msg::Control_AccSteerControl& Control::acc_steer_cmd() const {
  // @@protoc_insertion_point(field_get:sim_msg.Control.acc_steer_cmd)
  return _internal_acc_steer_cmd();
}
inline void Control::unsafe_arena_set_allocated_acc_steer_cmd(
    ::sim_msg::Control_AccSteerControl* acc_steer_cmd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(acc_steer_cmd_);
  }
  acc_steer_cmd_ = acc_steer_cmd;
  if (acc_steer_cmd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sim_msg.Control.acc_steer_cmd)
}
inline ::sim_msg::Control_AccSteerControl* Control::release_acc_steer_cmd() {
  
  ::sim_msg::Control_AccSteerControl* temp = acc_steer_cmd_;
  acc_steer_cmd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sim_msg::Control_AccSteerControl* Control::unsafe_arena_release_acc_steer_cmd() {
  // @@protoc_insertion_point(field_release:sim_msg.Control.acc_steer_cmd)
  
  ::sim_msg::Control_AccSteerControl* temp = acc_steer_cmd_;
  acc_steer_cmd_ = nullptr;
  return temp;
}
inline ::sim_msg::Control_AccSteerControl* Control::_internal_mutable_acc_steer_cmd() {
  
  if (acc_steer_cmd_ == nullptr) {
    auto* p = CreateMaybeMessage<::sim_msg::Control_AccSteerControl>(GetArenaForAllocation());
    acc_steer_cmd_ = p;
  }
  return acc_steer_cmd_;
}
inline ::sim_msg::Control_AccSteerControl* Control::mutable_acc_steer_cmd() {
  ::sim_msg::Control_AccSteerControl* _msg = _internal_mutable_acc_steer_cmd();
  // @@protoc_insertion_point(field_mutable:sim_msg.Control.acc_steer_cmd)
  return _msg;
}
inline void Control::set_allocated_acc_steer_cmd(::sim_msg::Control_AccSteerControl* acc_steer_cmd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete acc_steer_cmd_;
  }
  if (acc_steer_cmd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::sim_msg::Control_AccSteerControl>::GetOwningArena(acc_steer_cmd);
    if (message_arena != submessage_arena) {
      acc_steer_cmd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acc_steer_cmd, submessage_arena);
    }
    
  } else {
    
  }
  acc_steer_cmd_ = acc_steer_cmd;
  // @@protoc_insertion_point(field_set_allocated:sim_msg.Control.acc_steer_cmd)
}

// -------------------------------------------------------------------

// ControlSAIC

// double torqueReq = 1;
inline void ControlSAIC::clear_torquereq() {
  torquereq_ = 0;
}
inline double ControlSAIC::_internal_torquereq() const {
  return torquereq_;
}
inline double ControlSAIC::torquereq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.torqueReq)
  return _internal_torquereq();
}
inline void ControlSAIC::_internal_set_torquereq(double value) {
  
  torquereq_ = value;
}
inline void ControlSAIC::set_torquereq(double value) {
  _internal_set_torquereq(value);
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.torqueReq)
}

// double steerReq = 2;
inline void ControlSAIC::clear_steerreq() {
  steerreq_ = 0;
}
inline double ControlSAIC::_internal_steerreq() const {
  return steerreq_;
}
inline double ControlSAIC::steerreq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.steerReq)
  return _internal_steerreq();
}
inline void ControlSAIC::_internal_set_steerreq(double value) {
  
  steerreq_ = value;
}
inline void ControlSAIC::set_steerreq(double value) {
  _internal_set_steerreq(value);
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.steerReq)
}

// int32 driveModeReq = 3;
inline void ControlSAIC::clear_drivemodereq() {
  drivemodereq_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ControlSAIC::_internal_drivemodereq() const {
  return drivemodereq_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ControlSAIC::drivemodereq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.driveModeReq)
  return _internal_drivemodereq();
}
inline void ControlSAIC::_internal_set_drivemodereq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  drivemodereq_ = value;
}
inline void ControlSAIC::set_drivemodereq(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_drivemodereq(value);
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.driveModeReq)
}

// double brakePressureReq = 4;
inline void ControlSAIC::clear_brakepressurereq() {
  brakepressurereq_ = 0;
}
inline double ControlSAIC::_internal_brakepressurereq() const {
  return brakepressurereq_;
}
inline double ControlSAIC::brakepressurereq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.brakePressureReq)
  return _internal_brakepressurereq();
}
inline void ControlSAIC::_internal_set_brakepressurereq(double value) {
  
  brakepressurereq_ = value;
}
inline void ControlSAIC::set_brakepressurereq(double value) {
  _internal_set_brakepressurereq(value);
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.brakePressureReq)
}

// double accReq = 5;
inline void ControlSAIC::clear_accreq() {
  accreq_ = 0;
}
inline double ControlSAIC::_internal_accreq() const {
  return accreq_;
}
inline double ControlSAIC::accreq() const {
  // @@protoc_insertion_point(field_get:sim_msg.ControlSAIC.accReq)
  return _internal_accreq();
}
inline void ControlSAIC::_internal_set_accreq(double value) {
  
  accreq_ = value;
}
inline void ControlSAIC::set_accreq(double value) {
  _internal_set_accreq(value);
  // @@protoc_insertion_point(field_set:sim_msg.ControlSAIC.accReq)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sim_msg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sim_msg::Control_CONTROL_MODE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_CONTROL_MODE>() {
  return ::sim_msg::Control_CONTROL_MODE_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Control_GEAR_MODE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_GEAR_MODE>() {
  return ::sim_msg::Control_GEAR_MODE_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Control_CONTROL_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_CONTROL_TYPE>() {
  return ::sim_msg::Control_CONTROL_TYPE_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Control_TurnLight> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_TurnLight>() {
  return ::sim_msg::Control_TurnLight_descriptor();
}
template <> struct is_proto_enum< ::sim_msg::Control_FogLamp> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sim_msg::Control_FogLamp>() {
  return ::sim_msg::Control_FogLamp_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_control_2eproto
